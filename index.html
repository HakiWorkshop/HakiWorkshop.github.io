<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EchoRun â€” Amplified Arena</title>
<link rel="icon" href="favicon.ico" type="image/x-icon">
<style>
:root{
  --bg:#071222; --muted:#9aa4b2; --accent:#7ee787; --danger:#ff6b6b;
  --card: rgba(255,255,255,0.03);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#eaf4ff;background:
 radial-gradient(1200px 700px at 10% 20%, #071226 0%, #05101a 30%, #02060a 100%);}
.app{display:flex;flex-direction:column;min-height:100vh;padding:14px}
.header{display:flex;gap:12px;align-items:center}
h1{margin:0;font-size:20px}
.subtitle{color:var(--muted);font-size:13px}
.meta{margin-left:auto;display:flex;gap:8px;align-items:center}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:8px 10px;border-radius:10px;border:1px solid var(--card); color:#eaf4ff}
.btn{background:linear-gradient(180deg,#0f1b28,#07121a);border-radius:10px;padding:8px 10px;border:1px solid rgba(255,255,255,0.02);color:var(--accent);cursor:pointer}
.hud{display:flex;gap:10px;margin-top:12px;align-items:center}
canvas{display:block;margin:18px auto;border-radius:12px;background:linear-gradient(180deg,rgba(6,10,18,0.7),rgba(2,5,10,0.6));box-shadow:0 12px 40px rgba(56, 144, 97, 0.6);}
.footer{margin-top:auto;color:var(--muted);text-align:center;padding:10px;font-size:13px}
.big{font-weight:700;color:#fff}
.note{color:var(--muted);font-size:13px}
.small{font-size:12px;color:var(--muted)}
.upgrade-menu{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(5,15,25,0.95);border-radius:16px;padding:24px;border:1px solid rgba(255,255,255,0.1);z-index:100;width:400px;max-width:90vw;display:none}
.upgrade-option{background:rgba(255,255,255,0.05);border-radius:10px;padding:16px;margin:10px 0;cursor:pointer;border:1px solid rgba(255,255,255,0.05);transition:all 0.2s}
.upgrade-option:hover{background:rgba(255,255,255,0.1);border-color:var(--accent)}
.upgrade-option.maxed{background:rgba(126,231,135,0.1);border-color:var(--accent);cursor:default}
.upgrade-option.maxed:hover{background:rgba(126,231,135,0.1)}
.upgrade-option.disabled{opacity:0.5;cursor:not-allowed}
.upgrade-option.disabled:hover{background:rgba(255,255,255,0.05);border-color:rgba(255,255,255,0.05)}
.upgrade-title{font-weight:bold;margin-bottom:6px;color:#fff;display:flex;justify-content:space-between}
.upgrade-desc{font-size:13px;color:var(--muted)}
.upgrade-rarity{font-size:11px;padding:2px 6px;border-radius:4px;margin-left:8px}
.rarity-common{background:rgba(255,255,255,0.1);color:#fff}
.rarity-rare{background:rgba(77,171,247,0.3);color:#4dabf7}
.rarity-legendary{background:rgba(255,215,0,0.3);color:#ffd700}
.rarity-mythical{background:rgba(148,0,211,0.3);color:#da70d6}
.screen{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;background:rgba(2,6,12,0.9);z-index:50;opacity:1;visibility:visible;transition:opacity 0.2s ease, visibility 0.2s ease;}
.screen.hidden{opacity:0;visibility:hidden;pointer-events:none;}
.start-screen{background:radial-gradient(circle at 50% 30%, #0a1a2a 0%, #02060a 100%)}
.start-title{font-size:48px;font-weight:bold;margin-bottom:10px;background:linear-gradient(90deg, #7ee787, #4dabf7);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;text-align:center;text-shadow:0 0 20px rgba(126,231,135,0.5)}
.start-subtitle{font-size:18px;color:var(--muted);margin-bottom:40px;text-align:center;max-width:600px}
.start-btn{background:linear-gradient(90deg, #7ee787, #4dabf7);border:none;border-radius:12px;padding:14px 32px;font-size:18px;font-weight:bold;color:#02060a;cursor:pointer;transition:transform 0.2s, box-shadow 0.2s}
.start-btn:hover{transform:translateY(-2px);box-shadow:0 8px 20px rgba(126,231,135,0.3)}
.controls{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:30px;max-width:600px}
.control-group{background:rgba(255,255,255,0.05);border-radius:10px;padding:16px}
.control-title{font-weight:bold;margin-bottom:10px;color:#fff}
.control-item{display:flex;justify-content:space-between;margin:8px 0;font-size:14px}
.control-key{background:rgba(255,255,255,0.1);padding:4px 8px;border-radius:6px;font-family:monospace}
.death-screen{display:none}
.death-stats{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin:30px 0}
.death-stat{text-align:center}
.death-value{font-size:32px;font-weight:bold;color:#fff}
.death-label{font-size:14px;color:var(--muted)}
.player-trail{position:absolute;pointer-events:none;z-index:1}
.boss-health{position:absolute;top:20px;left:50%;transform:translateX(-50%);width:300px;height:20px;background:rgba(0,0,0,0.5);border-radius:10px;border:2px solid rgba(255,255,255,0.2);z-index:10;display:none}
.boss-health-bar{height:100%;background:linear-gradient(90deg, #ff6b6b, #ff8e8e);border-radius:8px;transition:width 0.3s}
.boss-health-text{position:absolute;top:0;left:0;width:100%;text-align:center;color:#fff;font-weight:bold;font-size:12px;line-height:20px}
.pulse{animation:pulse 2s infinite}
@keyframes pulse{0%{opacity:1}50%{opacity:0.7}100%{opacity:1}}
.boss-spawn-effect{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:200px;height:200px;border-radius:50%;background:radial-gradient(circle, rgba(255,0,0,0.8) 0%, rgba(255,0,0,0) 70%);animation:bossSpawn 1.5s ease-out;z-index:20;pointer-events:none}
@keyframes bossSpawn{0%{transform:translate(-50%,-50%) scale(0);opacity:1}50%{transform:translate(-50%,-50%) scale(1.5);opacity:0.7}100%{transform:translate(-50%,-50%) scale(2);opacity:0}}
@keyframes pulseExpand {
  0% {
    transform: translate(-50%, -50%) scale(0.5);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(3);
    opacity: 0;
  }
}

/* Update Log Styles */
/* Update Log Styles - ENHANCED VERSION */
.update-log-entry {
  background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.9));
  border-radius: 12px;
  padding: 20px;
  margin: 15px 0;
  border: 1px solid rgba(126, 231, 135, 0.2);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(10px);
}

.update-log-entry::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: linear-gradient(180deg, #7ee787, #4dabf7);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.update-log-entry:hover {
  transform: translateY(-4px);
  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3),
              0 0 0 1px rgba(126, 231, 135, 0.3);
  background: linear-gradient(135deg, rgba(20, 30, 48, 0.95), rgba(35, 48, 71, 0.95));
  border-color: rgba(126, 231, 135, 0.4);
}

.update-log-entry:hover::before {
  opacity: 1;
}

/* Pulsing glow effect for new entries */
.update-log-entry:first-child {
  animation: pulse-glow 3s infinite alternate;
  border: 1px solid rgba(126, 231, 135, 0.3);
}

@keyframes pulse-glow {
  0% {
    box-shadow: 0 0 15px rgba(126, 231, 135, 0.1),
                inset 0 0 15px rgba(126, 231, 135, 0.05);
  }
  100% {
    box-shadow: 0 0 25px rgba(126, 231, 135, 0.2),
                inset 0 0 20px rgba(126, 231, 135, 0.1);
  }
}

.update-log-title {
  font-weight: 700;
  font-size: 18px;
  color: #7ee787;
  margin-bottom: 6px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  font-family: 'Inter', sans-serif;
}

.update-log-title::before {
  content: 'ðŸ“°';
  margin-right: 10px;
  font-size: 16px;
  filter: drop-shadow(0 0 5px rgba(126, 231, 135, 0.5));
}

.update-log-date {
  font-size: 12px;
  color: #9aa4b2;
  margin-bottom: 15px;
  text-align: right;
  font-family: 'Monaco', 'Consolas', monospace;
  letter-spacing: 1px;
  padding: 4px 8px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  display: inline-block;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.update-log-content ul {
  margin: 10px 0 0 0;
  padding-left: 22px;
  position: relative;
}

.update-log-content ul::before {
  content: '';
  position: absolute;
  left: 8px;
  top: 5px;
  bottom: 5px;
  width: 2px;
  background: linear-gradient(180deg, #7ee787, #4dabf7, transparent);
  border-radius: 2px;
}

.update-log-content li {
  font-size: 15px;
  color: #cbd5e1;
  margin-bottom: 8px;
  line-height: 1.5;
  position: relative;
  padding-left: 10px;
  transition: all 0.2s ease;
}

.update-log-content li::before {
  content: 'â–¸';
  position: absolute;
  left: -18px;
  color: #7ee787;
  font-weight: bold;
  transition: all 0.2s ease;
}

.update-log-content li:hover {
  color: #ffffff;
  transform: translateX(3px);
}

.update-log-content li:hover::before {
  color: #4dabf7;
  transform: scale(1.2);
}

.update-log-content li strong {
  color: #ffffff;
  font-weight: 700;
  background: linear-gradient(90deg, #1a89a8, #b34df7);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 10px rgba(126, 231, 135, 0.3);
}

/* Category badges */
.update-log-content li strong:after {
  content: '';
  display: inline-block;
  width: 6px;
  height: 6px;
  background: #a83bde;
  border-radius: 50%;
  margin-left: 8px;
  vertical-align: middle;
  box-shadow: 0 0 8px #7ee787;
}

.update-log-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(135deg, rgba(5, 15, 25, 0.98), rgba(10, 25, 47, 0.98));
  border-radius: 20px;
  padding: 30px;
  border: 1px solid rgba(126, 231, 135, 0.2);
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5),
              0 0 0 1px rgba(126, 231, 135, 0.1),
              inset 0 1px 0 rgba(255, 255, 255, 0.1);
  z-index: 1000;
  width: 600px !important;
  max-width: 90vw;
  max-height: 80vh;
  overflow-y: auto;
  backdrop-filter: blur(20px);
  font-family: 'Inter', sans-serif;
}

.update-log-panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(126, 231, 135, 0.5), transparent);
}

.update-log-panel h2 {
  text-align: center;
  margin-bottom: 25px;
  font-size: 28px;
  color: #ffffff;
  text-transform: uppercase;
  letter-spacing: 1px;
  font-weight: 800;
  background: linear-gradient(90deg, #7ee787, #4dabf7);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 20px rgba(126, 231, 135, 0.3);
  position: relative;
  padding-bottom: 15px;
}

.update-log-panel h2::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 100px;
  height: 3px;
  background: linear-gradient(90deg, #7ee787, #4dabf7);
  border-radius: 2px;
}

/* Custom scrollbar for update log */
.update-log-panel::-webkit-scrollbar {
  width: 10px;
}

.update-log-panel::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 10px;
  margin: 5px;
}

.update-log-panel::-webkit-scrollbar-thumb {
  background: linear-gradient(180deg, #7ee787, #4dabf7);
  border-radius: 10px;
  border: 2px solid rgba(5, 15, 25, 0.5);
}

.update-log-panel::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(180deg, #4dabf7, #7ee787);
  box-shadow: 0 0 10px rgba(126, 231, 135, 0.5);
}

#closeUpdateLog {
  background: linear-gradient(135deg, #0f4c75, #3282b8);
  color: white;
  border: none;
  border-radius: 10px;
  padding: 14px 28px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  font-family: 'Inter', sans-serif;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  font-size: 14px;
  margin-top: 10px;
  box-shadow: 0 4px 15px rgba(15, 76, 117, 0.4);
  position: relative;
  overflow: hidden;
}

#closeUpdateLog::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.6s ease;
}

#closeUpdateLog:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 25px rgba(30, 60, 114, 0.6);
  background: linear-gradient(135deg, #3282b8, #0f4c75);
}

#closeUpdateLog:hover::before {
  left: 100%;
}

#closeUpdateLog:active {
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(15, 76, 117, 0.4);
}

/* Update Log Button Styles - ENHANCED */
.update-log-btn {
  background: linear-gradient(135deg, rgba(9, 6, 91, 0.4), rgba(61, 139, 202, 0.4)) !important;
  color: #63e6be !important;
  font-size: 15px !important;
  padding: 18px 24px !important;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
  border: 1px solid rgba(77, 171, 247, 0.3) !important;
  border-radius: 12px !important;
  font-weight: 700 !important;
  letter-spacing: 0.5px !important;
  text-transform: uppercase !important;
  font-family: 'Inter', sans-serif !important;
  position: relative !important;
  overflow: hidden !important;
  box-shadow: 0 4px 15px rgba(0, 53, 109, 0.4) !important;
}

.update-log-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.6s ease;
}

.update-log-btn:hover {
  background: linear-gradient(135deg, rgba(19, 14, 172, 0.5), rgba(70, 172, 255, 0.5)) !important;
  transform: translateY(-3px) !important;
  box-shadow: 0 8px 25px rgba(0, 53, 109, 0.7) !important;
  color: #99e6e6 !important;
  border-color: rgba(77, 171, 247, 0.6) !important;
}

.update-log-btn:hover::before {
  left: 100%;
}

.update-log-btn:active {
  background: linear-gradient(135deg, rgba(11, 8, 120, 0.4), rgba(77, 171, 247, 0.4)) !important;
  transform: translateY(-1px) !important;
  box-shadow: 0 4px 15px rgba(0, 53, 109, 0.5) !important;
}

.update-log-btn::after {
  content: 'ðŸ“°';
  margin-left: 10px;
  font-size: 16px;
  filter: drop-shadow(0 0 5px rgba(99, 230, 190, 0.5));
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .update-log-panel {
    padding: 20px;
    width: 95vw !important;
  }
  
  .update-log-entry {
    padding: 15px;
  }
  
  .update-log-title {
    font-size: 16px;
  }
  
  .update-log-content li {
    font-size: 14px;
  }
}
/* Pac-Man style health display */
.health-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 8px;
  z-index: 1000;
}

.health-title {
  color: #fff;
  font-size: 14px;
  font-weight: bold;
  text-shadow: 0 0 5px rgba(255,255,255,0.5);
  background: rgba(0,0,0,0.5);
  padding: 4px 8px;
  border-radius: 4px;
}

.health-display {
  display: flex;
  gap: 6px; /* Reduced from 8px */
  background: rgba(0,0,0,0.7);
  padding: 8px; /* Reduced from 10px */
  border-radius: 10px;
  border: 2px solid rgba(255,255,255,0.2);
  box-shadow: 0 0 20px rgba(255,107,107,0.3);
  flex-wrap: wrap;
  max-width: 150px; /* Reduced from 170px */
}

.health-unit {
  width: 24px; /* Reduced from 30px */
  height: 24px; /* Reduced from 30px */
  background: #ff6b6b;
  border-radius: 50%;
  position: relative;
  overflow: hidden;
  box-shadow: 0 0 8px rgba(255,107,107,0.5); /* Reduced glow */
  transition: all 0.3s ease;
}

/* Remove the .health-unit.empty class since we won't have empty spots */
.health-unit.full {
  background: #ff6b6b;
  animation: healthPulse 2s infinite;
}

/* Pac-Man mouth effect */
.health-unit::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 35%;
  height: 60%;
  background: #000;
  clip-path: polygon(100% 0, 100% 100%, 0 50%);
  transform: translate(-50%, -50%) rotate(45deg);
  animation: pacManMouth 0.5s infinite alternate;
}

@keyframes healthPulse {
  0% { box-shadow: 0 0 8px rgba(255,107,107,0.5); }
  50% { box-shadow: 0 0 16px rgba(255,107,107,0.8); }
  100% { box-shadow: 0 0 8px rgba(255,107,107,0.5); }
}

@keyframes pacManMouth {
  0% { clip-path: polygon(100% 0, 100% 100%, 0 50%); }
  100% { clip-path: polygon(100% 25%, 100% 75%, 0 50%); }
}

/* Damage flash effect */
.damage-flash {
  animation: damageFlash 0.5s ease;
}

@keyframes damageFlash {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); background: #fff; }
  100% { transform: scale(1); background: #ff6b6b; }
}

/* Shield display - also compact */
.shield-container {
  margin-top: 8px; /* Reduced from 10px */
}

.shield-title {
  color: #4dabf7;
  font-size: 12px;
  font-weight: bold;
  text-shadow: 0 0 5px rgba(77,171,247,0.5);
  background: rgba(0,0,0,0.5);
  padding: 3px 6px;
  border-radius: 4px;
}

.shield-display {
  display: flex;
  gap: 4px; /* Reduced from 6px */
  background: rgba(0,0,0,0.5);
  padding: 6px; /* Reduced from 8px */
  border-radius: 8px;
  border: 2px solid rgba(77,171,247,0.3);
}

.shield-unit {
  width: 16px; /* Reduced from 20px */
  height: 16px; /* Reduced from 20px */
  background: #4dabf7;
  border-radius: 50%;
  position: relative;
  box-shadow: 0 0 6px rgba(77,171,247,0.5); /* Reduced glow */
  transition: all 0.3s ease;
}

.shield-unit.full::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 60%;
  height: 60%;
  border: 1px solid #fff; /* Thinner border */
  border-radius: 50%;
  transform: translate(-50%, -50%);
}

/* Remove the .shield-unit.empty class since we won't have empty spots */
.level-up-notification{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(126,231,135,0.2);border:2px solid rgba(126,231,135,0.5);border-radius:12px;padding:20px;text-align:center;z-index:25;display:none;animation:pulse 1.5s infinite}
.level-up-text{font-size:24px;font-weight:bold;color:#7ee787;margin-bottom:10px}
.level-up-hint{font-size:14px;color:var(--muted)}
.spawn-indicator{position:absolute;z-index:5;pointer-events:none;opacity:0.7}
@media (max-width: 720px) {
  canvas {
    width: 98% !important;
    max-height: 70vh !important;
    margin: 5px auto;
  }
}/* subtle floating UI bounce */
.card{transform-origin:center}
.card.pulse{animation:uiPulse 1.8s ease-in-out infinite}
@keyframes uiPulse{0%{transform:translateY(0)}50%{transform:translateY(-3px)}100%{transform:translateY(0)}}
/* Upgrade rarity effects - less glowy */
.upgrade-option.rarity-legendary {position: relative; overflow: hidden; border: 1px solid rgba(255,215,0,0.5);}
.upgrade-option.rarity-rare {position: relative; overflow: hidden; border: 1px solid rgba(77,171,247,0.5);}
.upgrade-option.rarity-mythical {position: relative; overflow: hidden; border: 1px solid rgba(148,0,211,0.5);}

/* New ability effects */
.freeze-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(100, 150, 255, 0.1);
  pointer-events: none;
  z-index: 5;
  display: none;
}
.shockwave {
  position: absolute;
  border-radius: 50%;
  pointer-events: none;
  z-index: 4;
}
.guard {
  position: absolute;
  z-index: 6;
}
.ability-cooldown {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 200px;
  height: 10px;
  background: rgba(0,0,0,0.5);
  border-radius: 5px;
  display: none;
}
.ability-cooldown-bar {
  height: 100%;
  background: linear-gradient(90deg, #e77ec6, #f7724d);
  border-radius: 5px;
  transition: width 0.1s;
}
.ability-cooldown-text {
  position: absolute;
  top: -20px;
  left: 0;
  width: 100%;
  text-align: center;
  color: #fff;
  font-size: 10px;
}
.damage-zone {
  position: absolute;
  z-index: 3;
  pointer-events: none;
}
.minigun-bullet {
  position: absolute;
  z-index: 2;
  pointer-events: none;
}
.safer-spaces {
  position: absolute;
  z-index: 7;
  pointer-events: none;
}
/* Pause menu */
.pause-menu {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(5,15,25,0.95);
  border-radius: 16px;
  padding: 24px;
  border: 1px solid rgba(255,255,255,0.1);
  z-index: 100;
  width: 500px;
  max-width: 90vw;
  display: none;
}
.pause-title {
  text-align: center;
  margin-bottom: 20px;
  font-size: 24px;
  color: #fff;
}
.upgrades-list {
  max-height: 300px;
  overflow-y: auto;
  margin-bottom: 20px;
}
.upgrade-item {
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  padding: 10px;
  margin: 5px 0;
  display: flex;
  justify-content: space-between;
}
.upgrade-name {
  font-weight: bold;
}
.upgrade-level {
  color: var(--accent);
}
.refresh-btn {
  background: linear-gradient(90deg, #7ee787, #4dabf7);
  border: none;
  border-radius: 8px;
  padding: 8px 16px;
  color: #02060a;
  cursor: pointer;
  font-weight: bold;
  margin-right: 10px;
}
.refresh-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Hardcore Mode Styles */
.hardcore-mode .card {
  border-color: rgba(255, 107, 107, 0.1);
  background: linear-gradient(180deg, rgba(255, 107, 107, 0.05), rgba(255, 107, 107, 0.02));
}

.hardcore-mode .btn {
  background: linear-gradient(180deg, #2a1515, #1a0a0a);
  border-color: rgba(255, 107, 107, 0.1);
  color: #ff6b6b;
}

.hardcore-mode .start-btn {
  background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
}

.hardcore-mode .start-title {
  background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
}

.hardcore-mode canvas {
  box-shadow: 0 12px 40px rgba(255, 0, 0, 0.3);
  border: 1px solid rgba(255, 107, 107, 0.1);
}

/* Freemode Styles */
.freemode-mode .card {
  border-color: rgba(77, 171, 247, 0.1);
  background: linear-gradient(180deg, rgba(77, 171, 247, 0.05), rgba(77, 171, 247, 0.02));
}

.freemode-mode .btn {
  background: linear-gradient(180deg, #15253a, #0a1a2a);
  border-color: rgba(77, 171, 247, 0.1);
  color: #4dabf7;
}

.freemode-mode .start-btn {
  background: linear-gradient(90deg, #4dabf7, #63e6be);
}

.freemode-mode .start-title {
  background: linear-gradient(90deg, #4dabf7, #63e6be);
}

.freemode-mode canvas {
  box-shadow: 0 12px 40px rgba(0, 100, 255, 0.3);
  border: 1px solid rgba(77, 171, 247, 0.1);
}

/* Force wider update log panel */
#updateLogPanel.update-log-panel,
#updateLogPanel {
  width: 500px !important;
  max-width: 95vw !important;
}



</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div>
      <h1>EchoRun â€” Amplified Arena</h1>
      <div class="subtitle">Survive the hostile echoes in this fast-paced arena shooter. Collect upgrades and master movement!</div>
    </div>
    <div class="meta">
      <div class="card">Score: <span id="score" class="big">0</span></div>
      <div class="card">Time: <span id="time" class="big">0s</span></div>
      <button id="restart" class="btn">Restart</button>
    </div>
  </div>

  <div class="hud">
    <div class="card">High: <span id="hi">0</span></div>
    <div class="card">Echoes: <span id="echoCount">0</span></div>
    <div class="card">Diff: <span id="diff">Normal</span></div>
    <div class="card">Level: <span id="level">1</span></div>
    <div class="card">Lives: <span id="lives">3</span></div>
    <div style="margin-left:auto" class="small">Aim with mouse â€” Click to fire â€” TAB for upgrades â€” M for auto-fire â€” L for emergency ability â€” P to pause</div>
  </div>

  <canvas id="c" width="1400" height="800"></canvas>
  <div class="boss-health" id="bossHealth">
    <div class="boss-health-bar" id="bossHealthBar"></div>
    <div class="boss-health-text" id="bossHealthText"></div>
  </div>

  <div class="ability-cooldown" id="abilityCooldown">
    <div class="ability-cooldown-bar" id="abilityCooldownBar"></div>
    <div class="ability-cooldown-text" id="abilityCooldownText">Emergency Ability</div>
  </div>

  <div class="footer"><a href="https://docs.google.com/forms/d/e/1FAIpQLSfB9VY6w7RTKy6BjeMSk1iUXJw180RqMyDLlhEo_D1ZczEY-w/viewform">Feekback her</a>
Made for fun Â· Local high score stored in your browser Â· Tip: click to enable audio</div>
</div>

<div id="startScreen" class="screen start-screen">
  <h1 class="start-title">ECHORUN ARENA</h1>
  <p class="start-subtitle">Survive the hostile echoes in this fast-paced arena shooter. Collect upgrades, master movement, and set a new high score!</p>
  
  <div style="display: flex; gap: 20px; margin-bottom: 30px;">
    <button id="classicBtn" class="start-btn pulse">CLASSIC MODE</button>
    <button id="hardcoreBtn" class="start-btn">HARDCORE MODE</button>
    <button id="freemodeBtn" class="start-btn">FREEMODE</button>
  </div>

<div style="position: absolute; bottom: 30px; left: 30px;">
  <button id="newFeatureBtn" class="start-btn update-log-btn">
    ðŸ“°News
  </button>
</div>
  
  <div class="controls">
    <div class="control-group">
      <div class="control-title">Control</div>
      <div class="control-item"><span>Move</span><span class="control-key">WASD / Arrows</span></div>
      <div class="control-item"><span>Upgrade Menu</span><span class="control-key">TAB</span></div>
      <div class="control-item"><span>Emergency Ability</span><span class="control-key">L</span></div>
      <div class="control-item"><span>Pause</span><span class="control-key">P</span></div>
    </div>
    <div class="control-group">
      <div class="control-title">Combat</div>
      <div class="control-item"><span>Aim</span><span class="control-key">MOUSE</span></div>
      <div class="control-item"><span>Fire</span><span class="control-key">MOUSE CLICK/HOLD</span></div>
      <div class="control-item"><span>Auto Aim</span><span class="control-key">N</span></div>
      <div class="control-item"><span>Auto Fire</span><span class="control-key">M</span></div>
    </div>
  </div>
</div>

<div id="deathScreen" class="screen death-screen">
  <h1 class="start-title">MISSION FAILED</h1>
  <p class="start-subtitle">The echoes overwhelmed your defenses. Ready for another attempt?</p>
  
  <div class="death-stats">
    <div class="death-stat">
      <div class="death-value" id="finalScore">0</div>
      <div class="death-label">Score</div>
    </div>
    <div class="death-stat">
      <div class="death-value" id="finalTime">0s</div>
      <div class="death-label">Survival Time</div>
    </div>
    <div class="death-stat">
      <div class="death-value" id="echoesDefeated">0</div>
      <div class="death-label">Echoes Defeated</div>
    </div>
    <div class="death-stat">
      <div class="death-value" id="upgradesCollected">0</div>
      <div class="death-label">Upgrades Collected</div>
    </div>
  </div>
  
  <button id="restartFromDeath" class="start-btn">TRY AGAIN</button>
</div>

<div id="upgradeMenu" class="upgrade-menu">
  <h2 style="text-align:center;margin-bottom:20px">UPGRADE AVAILABLE</h2>
  <div id="upgradeOptions"></div>
  <div style="text-align:center;margin-top:20px;color:var(--muted);font-size:12px">Select an upgrade to continue</div>
  <div style="text-align:center;margin-top:10px;">
    <button id="refreshUpgrades" class="refresh-btn" disabled>REFRESH (1/1)</button>
  </div>
</div>

<div id="pauseMenu" class="pause-menu">
  <h2 class="pause-title">GAME PAUSED</h2>
  <div class="upgrades-list" id="upgradesList"></div>
  <div style="text-align:center">
    <button id="resumeBtn" class="start-btn">RESUME</button>
  </div>
</div>

<div id="freezeOverlay" class="freeze-overlay"></div>

<!-- Pac-Man Style Health Display -->
<div id="healthDisplay" class="health-container">
  <div class="health-title">LIVES</div>
  <div id="healthUnits" class="health-display">
    <!-- Health units will be generated here -->
  </div>
  
  <div id="shieldDisplay" class="shield-container">
    <div class="shield-title">SHIELD</div>
    <div id="shieldUnits" class="shield-display">
      <!-- Shield units will be generated here -->
    </div>
  </div>
</div>

<div id="updateLogPanel" class="upgrade-menu" style="display: none;">
  <h2 style="text-align:center;margin-bottom:20px">UPDATE LOG</h2>
  <div class="update-log-title">Updated version - V.21</div>
  <div style="max-height: 500px; overflow-y: auto; padding-right: 10px;">
    
        <div class="update-log-entry">
      <div class="update-log-title">New Balance changes</div>
      <div class="update-log-date">30.12.2025</div>
      <div class="update-log-content">
        <ul>
          <p><strong>Balance Changes</strong></p>
          <li><strong>Reflective mirror - Battle Nerve</strong></li>
          <li><b>Buff</b> - Chances changed from 20% -> 35% -> 50% <b>to</b> 30% -> 50% -> 70%</li>
          <li><strong>Music upgrade</strong></li>
          <li><b>Buff</b> - Increased stat increase with 5% going from 15% to 20%. Now allso increases player lives with 20%</li>
          <li>Changed name to "Battle Nerve</li>

          <p><strong>NEW & ADDED!</strong></p>

          <p><strong>Bug fixes</strong></p>
        </ul>
      </div>
    </div>

    <!-- Copy pase update log -->
    <div class="update-log-entry">
      <div class="update-log-title">Changes</div>
      <div class="update-log-date">11.01.2026</div>
      <div class="update-log-content">
        <ul>
          <p><strong>Boss System Fix</strong></p>
          <li>Boss system broke down in a previous update. In this new version its working perfectly fine with minimal bugs. Bosses now spawn how they are suposed to when they are suposed to.</li>

          <p><strong>NEW & ADDED!</strong></p>
          <li><strong>NEW âŠ™ Lightning strike</strong></li>
          <li>The most powerfull ability added to the game so far - fires out a power lightning strike hitting muliple neaby enemies in a row dealing great damage. Ability can chain torugh more enemies if you upgrade extend range as well.</li>
          <li>Max 2 - Mythical</li>
          <li><strong>NEW âŠ™ Dangerous situations</strong></li>
          <li>A new ability that allows you to refresh your ability timer on taking damage</li>
          <li>Max 1 - Rare</li>
          <li><strong>NEW âŠ™ Reflective Mirror</strong></li>
          <li>Brand new ability that acts as a shield around you with a chance to reflect incoming bullets</li>
          <li>Reflected bullets deals more damage</li>
          <li>Reflect chances - 20% -> 35% -> 50%</li>
          <li>Max 3 - Rare</li>

          <p><strong>Balance Changes</strong></p>
          <li><strong>Explosive enemy - Buff</strong></li>
          <li>Moves twice as fast</li>
          <li>Slims now spawns a little closer to each other</li>
          <li><strong>Sniper Enemy - Nerf</strong></li>
          <li>40% Less health</li>          
          <li><strong>Final boss - Buff</strong></li>
          <li>Phase system buffed - now turned upside down, starts slow but fires faster.</li>

          <p><strong>Ability Reworks</strong></p>
          <li><strong>Ghost</strong></li>
          <li>Rework - Now chases nearest enemy (Used to chase strongest)</li>
          <li><strong>Rocket</strong></li>
          <li>Rework - Now deals 1/5th the damage but has a 5x bigger chance of appearing</li>
          <li>Now max 1 upgrade (used to be 2)</li>
          <li><strong>Fire pulse</strong></li>
          <li>Rework - Smaller area, less damage, much more frequent (5x more frequent)</li>
          <li><strong>Minibot</strong></li>
          <li>Rework - Added bots are now 2 -> 4 -> 6 -> 10 </li>
          <li>Instead of - Added bots are now 1 -> 3 -> 6 -> 12 </li>

          <p><strong>Bug fixes</strong></p>
          <li><strong>Guards</strong></li>
          <li>Now spawns in a propper circle, scaling with difficulty</li>
          <li><strong>Death bug</strong></li>
          <li>Player can now die from enemy bullets</li>
          <li><strong>Safer spaces</strong></li>
          <li>Ability can now take damage from enemy bullets and break proppely</li>
          <li><strong>Various minor fixes</strong></li>
        </ul>
      </div>
    </div>


    <div class="update-log-entry">
      <div class="update-log-title">Old Balance changes</div>
      <div class="update-log-date">30.12.2025</div>
      <div class="update-log-content">
        <ul>
          <li><strong>Shockwave</strong></li>
          <li>Cooldown 12s -> 7s</li>
          <li>Damage radius decrased by 25%</li>
          <li>Damage dealt scales per red killed</li>
          <li><strong>Music upgrade</strong></li>
          <li>Removed old scaling buff</li>
          <li>Improve all player stats by 15%</li>
          <li><strong>Ghost</strong></li>
          <li>Increasd chances for all upgrades</li>
          <li>Ghost overall buffed</li>
          <li><strong>WorkerCollector</strong></li>
          <li>Increased movement speed by 25%</li>

          <p><strong>NEW & ADDED!</strong></p>
          <li><strong>Minelayer ability:</strong> New standard ability that shoots out mines! Comes with upgrades.</li>
          <li><strong>Witch enemy</strong> New enemy spawning randomly around in the game, spawns different enemies</li>

          <p><strong>Bug fixes</strong></p>
          <li><strong>XP magnet</strong></li>
          <li>Fixed xp pull mechansim - Everything works perfectly fine</li>
          <li><strong>Coming Fixes:</strong></li>
          <li>Boss spawning system</li>
          <li>Minibot spawning issues</li>
          <li>Various minor fixes</li>
        </ul>
      </div>
    </div>

  <div style="text-align:center;margin-top:20px;">
    <button id="closeUpdateLog" class="btn" style="
      background: linear-gradient(135deg, #0f4c75, #3282b8);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(15, 76, 117, 0.3);
    ">
      Close
    </button>
  </div>
</div>


<script>
// EchoRun â€” Amplified Edition
// Enhanced with new abilities and features

(() => {
  // canvas & context
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;
  const scoreEl = document.getElementById('score');
  const timeEl = document.getElementById('time');
  const hiEl = document.getElementById('hi');
  const echoCountEl = document.getElementById('echoCount');
  const diffEl = document.getElementById('diff');
  const levelEl = document.getElementById('level');
  const livesEl = document.getElementById('lives');
  const startScreen = document.getElementById('startScreen');
  const deathScreen = document.getElementById('deathScreen');
  const upgradeMenu = document.getElementById('upgradeMenu');
  const upgradeOptions = document.getElementById('upgradeOptions');
  const pauseMenu = document.getElementById('pauseMenu');
  const upgradesList = document.getElementById('upgradesList');
  const classicBtn = document.getElementById('classicBtn');
  const hardcoreBtn = document.getElementById('hardcoreBtn');
  const freemodeBtn = document.getElementById('freemodeBtn');
  const restartFromDeath = document.getElementById('restartFromDeath');
  const finalScore = document.getElementById('finalScore');
  const finalTime = document.getElementById('finalTime');
  const echoesDefeated = document.getElementById('echoesDefeated');
  const upgradesCollected = document.getElementById('upgradesCollected');
  const bossHealth = document.getElementById('bossHealth');
  const bossHealthBar = document.getElementById('bossHealthBar');
  const bossHealthText = document.getElementById('bossHealthText');
  const abilityCooldown = document.getElementById('abilityCooldown');
  const abilityCooldownBar = document.getElementById('abilityCooldownBar');
  const abilityCooldownText = document.getElementById('abilityCooldownText');
  const freezeOverlay = document.getElementById('freezeOverlay');
  const refreshUpgrades = document.getElementById('refreshUpgrades');
  const resumeBtn = document.getElementById('resumeBtn');
  
  const levelUpNotification = document.createElement('div');
  levelUpNotification.className = 'level-up-notification';
  levelUpNotification.innerHTML = `
    <div class="level-up-text">LEVEL UP!</div>
    <div class="level-up-hint">Press TAB to choose an upgrade</div>
  `;
  document.body.appendChild(levelUpNotification);

  // Game mode
  let gameMode = 'classic'; // 'classic', 'hardcore', 'freemode'

  // state
  let lastTime = performance.now(), running = false, gameStarted = false;
  let timeAlive = 0, score = 0, high = Number(localStorage.getItem('echoswap-hi') || 0);
  let playerLevel = 1, playerXP = 0, xpToNextLevel = 100;
  let echoesKilled = 0, upgradesGathered = 0, bossesKilled = 0, megaBossActive = false;
  let lastMouseMove = 0;
  let upgradeSelectionCooldown = 0;
  let killBoostTimer = 0;
  let pendingUpgrades = 1;
  let tabPressed = false;
  let gamePaused = false;
  let shield = 0;
  let shieldTimer = 0;
  let shieldDamageCooldown = 0;
  let bulletCounter = 0;
  let sprintTimer = 0;
  let endlessMode = false;
  let bossUpgradePending = false;
  let mythicalDropTimer = 0;
  let maxLevelReached = false;
  let refreshUsed = false;
  let upgradeInvulTimer = 0;
  let reflectiveMirrorActive = false;
  let reflectiveMirrorRadius = 80;
  let reflectiveMirrorChance = 0.3;
  let reflectiveMirrorPulse = 0;
  let damageZonePulse = 0;
  let damageZoneInnerPulse = 0;
  let damageZoneRotation = 0;
  let damageZoneDamageParticles = [];

  // New boss tracking system
  let bossSpawnTimer = 0;
  let bossSpawnEffect = null;
  let bossSpawnSchedule = [
    { time: 30, type: 'easy', spawned: false, killed: false },
    { time: 70, type: 'medium', spawned: false, killed: false },
    { time: 120, type: 'hard', spawned: false, killed: false },
    { time: 200, type: 'final', spawned: false, killed: false },
    { time: 350, type: 'creeper', spawned: false, killed: false }
  ];
  let activeBosses = [];
  let bossHealthBars = [];


  // Upgrade chance tracking
  let commonChance = 60;
  let rareChance = 30;
  let legendaryChance = 9; //maxed at 16
  let mythicalChance = 1; // maxed at 7
  let lastChanceUpdate = 0;

// Emergency ability tracking
let emergencyAbility = 'minelayer'; // Default ability
let emergencyAbilityCooldown = 0;
let emergencyAbilityActive = false;
let emergencyAbilityTimer = 0;

// Emergency ability power levels (higher = stronger)
const abilityPowerLevels = {
  'mineLayer': 1,      // Basic
  'mineCount': 1,      // Basic
  'lastResort': 2,     // Rare
  'freeze': 3,         // Legendary
  'saferSpaces': 3,    // Legendary
  'shockwave': 4,      // Mythical
  'guards': 4,         // Mythical
};

// Track selected abilities to prevent weaker ones from appearing
let selectedAbilities = new Set(['mineLayer']); // Start with mineLayer

  let minesActive = false;
  let mines = [];
  let mineTimer = 0;
  let freezeActive = false;
  let freezeTimer = 0;
  let lastResortActive = false;
  let lastResortTimer = 0;
  let guardsActive = false;
  let guardsTimer = 0;
  let shockwaveActive = false;
  let shockwaveTimer = 0;
  let shockwaveRadius = 0;
  let shockwaveDamage = 1;
  let saferSpacesActive = false;
  let saferSpacesTimer = 0;
  let saferSpacesHealth = 5;
  let damageZoneActive = false;
  let damageZoneTimer = 0;
  let damageZoneAngle = 0;
  let minigunActive = false;
  let minigunTimer = 0;
  let minigunBullets = [];
  let lightningStrikes = [];
  let lightningStrikeTimer = 0;
  let lightningStrikeCooldown = 0;
  let lightningStrikeActive = false;

  // Guards array
  const guards = [];

  let lastResortEffectTimer = 0;
  
  // Safer Spaces wall
  let saferSpacesWall = null;

  // Audio elements
  let backgroundsong, passive, adamMusic;
  let isAdamPlaying = false;

// Function to change background based on game mode
function updateBackgroundForGameMode(mode) {
  const app = document.querySelector('.app');
  
  // Remove any existing game mode classes
  app.classList.remove('hardcore-mode', 'freemode-mode');
  
  // Add appropriate class for the game mode
  if (mode === 'hardcore') {
    app.classList.add('hardcore-mode');
    document.body.style.background = 
      'radial-gradient(1200px 700px at 10% 20%, #2a0a0a 0%, #1a0505 30%, #0a0202 100%)';
  } else if (mode === 'freemode') {
    app.classList.add('freemode-mode');
    document.body.style.background = 
      'radial-gradient(1200px 700px at 10% 20%, #0a2a3a 0%, #051525 30%, #020a15 100%)';
  } else {
    // Classic mode - reset to defaults
    app.classList.remove('hardcore-mode', 'freemode-mode');
    document.body.style.background = 
      'radial-gradient(1200px 700px at 10% 20%, #071226 0%, #05101a 30%, #02060a 100%)';
  }
}

// Initialize audio
function initAudio() {
  // Create audio elements with actual file sources
  backgroundsong = new Audio('backgroundsong.mp3');
  backgroundsong.loop = true;
  backgroundsong.volume = 0.1;
  
  passive = new Audio('passive.mp3');
  passive.loop = true;
  passive.volume = 0.1;
  
  adamMusic = new Audio('adam.mp3');
  adamMusic.loop = true;
  adamMusic.volume = 0.1;
  
  // Start passive music immediately
  passive.play().catch(e => console.log('Passive music play failed:', e));
}
  // Play background music
  function playbackgroundsong() {
    passive.pause(); // Stop passive music when starting game
    backgroundsong.currentTime = 0;
    backgroundsong.play().catch(e => console.log('Background music play failed:', e));
  }

  // Play Adam music
  function playAdamMusic() {
    if (isAdamPlaying) return;
    
    backgroundsong.pause();
    passive.pause();
    adamMusic.currentTime = 0;
    adamMusic.play().catch(e => console.log('Adam music play failed:', e));
    isAdamPlaying = true;
  }

  // Stop all music
  function stopAllMusic() {
    backgroundsong.pause();
    passive.pause();
    adamMusic.pause();
    isAdamPlaying = false;
  }

  // player
  const player = { 
    x: W/2, y: H/2, r: 14, vx:0, vy:0, speed:250, invul:0,
    fireRate: 0.6,
    bulletSpeed: 460, bulletSize: 6, bulletLife: 0.5,
    spread: 0.18,
    knockback: 1.0, lives: 3,
    trail: [], maxTrail: 20,
    autoFire: 0, autoFireRate: 0,
    workers: [], maxWorkers: 0, workerLevel: 0,
    damageMultiplier: 1.0,
    autoAim: true,
    autoFireToggle: true,
    sprint: { level: 0, max: 3, rarity: 'rare' },
    stats: {
      fireRate: {level: 0, max: 5, rarity: 'common'},
      bulletSpeed: {level: 0, max: 3, rarity: 'common'},
      movement: {level: 0, max: 5, rarity: 'common'},
      knockback: {level: 0, max: 1, rarity: 'common'},
      bulletSize: {level: 0, max: 3, rarity: 'common'},
      bulletLife: {level: 0, max: 2, rarity: 'common'},
      xpBoost: {level: 0, max: 5, rarity: 'common'},
      extraLife: {level: 0, max: 1, rarity: 'rare'},
      workers: {level: 0, max: 4, rarity: 'legendary'},
      ghost: {level: 0, max: 3, rarity: 'legendary'},
      holyLife: {level: 0, max: 1, rarity: 'legendary'},
      killBoost: {level: 0, max: 3, rarity: 'rare'},
      boomerang: {level: 0, max: 3, rarity: 'legendary'},
      fire: {level: 0, max: 2, rarity: 'mythical'},
      shotgun: {level: 0, max: 5, rarity: 'rare'},
      shield: {level: 0, max: 3, rarity: 'rare'},
      shieldRegen: {level: 0, max: 2, rarity: 'legendary'},
      health: {level: 0, max: 2, rarity: 'common'},
      damage: {level: 0, max: 5, rarity: 'common'},
      sprint: {level: 0, max: 3, rarity: 'rare'},
      rocket: {level: 0, max: 1, rarity: 'legendary'},
      powerBullet: {level: 0, max: 3, rarity: 'rare'},
      knockbackBullets: {level: 0, max: 4, rarity: 'rare'},
      workerCollector: {level: 0, max: 4, rarity: 'rare'},
      flanker: {level: 0, max: 7, rarity: 'common'},
      shockwave: {level: 0, max: 1, rarity: 'mythical'},
      guards: {level: 0, max: 1, rarity: 'mythical'},
      freeze: {level: 0, max: 1, rarity: 'legendary'},
      lastResort: {level: 0, max: 2, rarity: 'rare'},
      music: {level: 0, max: 1, rarity: 'mythical'},
      damageZone: {level: 0, max: 2, rarity: 'legendary'},
      minigun: {level: 0, max: 5, rarity: 'rare'},
      saferSpaces: {level: 0, max: 1, rarity: 'legendary'},
      mineCount: {level: 0, max: 3, rarity: 'common'},
      cooldownRefresh: {level: 0, max: 1, rarity: 'rare'},
      reflectiveMirror: {level: 0, max: 3, rarity: 'rare'},
      lightningStrike: {level: 0, max: 2, rarity: 'mythical'}
    }
  };

  // input
  const input = { left:false, right:false, up:false, down:false, mx:W/2, my:H/2, mouseDown:false, mouseClicked: false };
  window.addEventListener('mousemove', e => {
    const r = canvas.getBoundingClientRect();
    input.mx = (e.clientX - r.left) * (canvas.width / r.width);
    input.my = (e.clientY - r.top) * (canvas.height / r.height);
    lastMouseMove = performance.now();
  });
  window.addEventListener('mousedown', e => { 
    input.mouseDown = true; 
    input.mouseClicked = true;
    audioResume(); 
  });
  window.addEventListener('mouseup', e => input.mouseDown = false);
  window.addEventListener('keydown', e => {
    if (['ArrowLeft','a'].includes(e.key)) input.left = true;
    if (['ArrowRight','d'].includes(e.key)) input.right = true;
    if (['ArrowUp','w'].includes(e.key)) input.up = true;
    if (['ArrowDown','s'].includes(e.key)) input.down = true;
    if (e.key === 'Tab') {
      e.preventDefault();
      if (gameStarted && !tabPressed) {
        tabPressed = true;
        if (pendingUpgrades > 0 && !gamePaused && !maxLevelReached) {
          gamePaused = true;
          showUpgradeMenu();
        }
      }
    }
    if (e.key === 'n' || e.key === 'N') {
      player.autoAim = !player.autoAim;
    }
    if (e.key === 'm' || e.key === 'M') {
      player.autoFireToggle = !player.autoFireToggle;
    }
    // Emergency ability activation
    if ((e.key === 'l' || e.key === 'L') && emergencyAbilityCooldown <= 0 && !emergencyAbilityActive) {
      activateEmergencyAbility();
    }

    // Pause game - FIXED: Can't pause while upgrade menu is open
    //YAYYY
    if (e.key === 'p' || e.key === 'P') {
        if (gameStarted && running && upgradeMenu.style.display !== 'block') {
            gamePaused = !gamePaused;
            if (gamePaused) {
                showPauseMenu();
            } else {
                hidePauseMenu();
            }
        }
    }
    audioResume();
  });
  window.addEventListener('keyup', e => {
    if (['ArrowLeft','a'].includes(e.key)) input.left = false;
    if (['ArrowRight','d'].includes(e.key)) input.right = false;
    if (['ArrowUp','w'].includes(e.key)) input.up = false;
    if (['ArrowDown','s'].includes(e.key)) input.down = false;
    if (e.key === 'Tab') tabPressed = false;
  });

  // audio
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function audioResume(){ 
  if (!audioCtx) audioCtx = new AudioCtx(); 
  if (audioCtx.state === 'suspended') audioCtx.resume();
  
  // Resume music if needed
  if (gameStarted && backgroundsong && backgroundsong.paused && !isAdamPlaying) {
    backgroundsong.play().catch(e => console.log('Background music resume failed:', e));
  } else if (!gameStarted && passive && passive.paused && !isAdamPlaying) {
    passive.play().catch(e => console.log('Passive music resume failed:', e));
  } else if (isAdamPlaying && adamMusic && adamMusic.paused) {
    adamMusic.play().catch(e => console.log('Adam music resume failed:', e));
  }
}
  
  function sfx(freq, dur=0.06, vol=0.02, type='sine'){ try{
    if(!audioCtx) audioCtx = new AudioCtx();
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination); o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur); o.stop(audioCtx.currentTime + dur);
  }catch(e){} }
  
  function playSound(type) {
    switch(type) {
      case 'enemySpawn':
        sfx(300, 0.1, 0.02, 'sawtooth');
        break;
      case 'slimSpawn':
        sfx(400, 0.05, 0.015, 'square');
        break;
      case 'tankThrow':
        sfx(150, 0.2, 0.03, 'sawtooth');
        break;
      case 'bowFire':
        sfx(600, 0.08, 0.015, 'sine');
        break;
      case 'witchCast':
        sfx(250, 0.15, 0.025, 'triangle');
        break;
      case 'sprint':
        sfx(800, 0.1, 0.02, 'sine');
        break;
      case 'heal':
        sfx(1200, 0.2, 0.03, 'sine');
        break;
      case 'rocket':
        sfx(100, 0.4, 0.05, 'sawtooth');
        break;
      case 'fire':
        sfx(120, 0.3, 0.04, 'sawtooth');
        break;
      case 'shockwave':
        sfx(80, 1.0, 0.08, 'sawtooth');
        break;
      case 'freeze':
        sfx(200, 0.5, 0.06, 'sine');
        break;
      case 'lastResort':
        sfx(400, 0.3, 0.05, 'square');
        break;
      case 'guards':
        sfx(600, 0.2, 0.04, 'sawtooth');
        break;
      case 'damageZone':
        sfx(150, 0.3, 0.04, 'sawtooth');
        break;
      case 'minigun':
        sfx(800, 0.05, 0.015, 'sawtooth');
        break;
      case 'saferSpaces':
        sfx(300, 0.5, 0.06, 'square');
        break;
      case 'lightning':
        sfx(1500, 0.1, 0.04, 'square');
        break;
    }
  }

  // world & gameplay
  const echoes = [], bullets = [], paints = [], particles = [], records = [], upgrades = [], ghosts = [], bombs = [], fires = [], rockets = [];
  const spawnIndicators = [];
  let recordTimer = 0, echoSpawnTimer = 0, difficulty = 1;
  let fireTimer = 0, autoFireTimer = 0, workerFireTimer = 0;
  let shake = 0;
  let upgradeAvailable = false;
  
  // Shockwave array
  const shockwaves = [];

  // helpers
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const rand = (a,b) => a + Math.random()*(b-a);
  const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);
  function vecTo(fromX, fromY, toX, toY){ const dx = toX-fromX, dy = toY-fromY; const m = Math.hypot(dx,dy)||1; return {x:dx/m,y:dy/m,mag:m}; }
  
  // Screen flash effect
  function createScreenFlash(color, duration) {
    const flash = document.createElement('div');
    flash.style.position = 'fixed';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.backgroundColor = color;
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '9998';
    flash.style.opacity = '0.7';
    flash.style.transition = `opacity ${duration}s ease-out`;
    document.body.appendChild(flash);
    
    setTimeout(() => {
      flash.style.opacity = '0';
      setTimeout(() => {
        if (flash.parentNode) {
          flash.parentNode.removeChild(flash);
        }
      }, duration * 1000);
    }, 10);
  }

  // Damage indicator text
  function createDamageIndicator(x, y, text) {
    const indicator = document.createElement('div');
    indicator.textContent = text;
    indicator.style.position = 'absolute';
    indicator.style.left = x + 'px';
    indicator.style.top = y + 'px';
    indicator.style.color = '#ff6b6b';
    indicator.style.fontSize = '20px';
    indicator.style.fontWeight = 'bold';
    indicator.style.textShadow = '0 0 5px rgba(0,0,0,0.8)';
    indicator.style.pointerEvents = 'none';
    indicator.style.zIndex = '9999';
    indicator.style.transform = 'translate(-50%, -50%)';
    indicator.style.transition = 'all 0.8s ease-out';
    document.body.appendChild(indicator);
    
    setTimeout(() => {
      indicator.style.top = (y - 50) + 'px';
      indicator.style.opacity = '0';
      setTimeout(() => {
        if (indicator.parentNode) {
          indicator.parentNode.removeChild(indicator);
        }
      }, 800);
    }, 10);
  }

  // Upgrade available pulse effect
  function createUpgradePulse() {
    const pulse = document.createElement('div');
    pulse.style.position = 'absolute';
    pulse.style.top = '50%';
    pulse.style.left = '50%';
    pulse.style.transform = 'translate(-50%, -50%)';
    pulse.style.width = '300px';
    pulse.style.height = '300px';
    pulse.style.borderRadius = '50%';
    pulse.style.background = 'radial-gradient(circle, rgba(126,231,135,0.3) 0%, rgba(126,231,135,0) 70%)';
    pulse.style.pointerEvents = 'none';
    pulse.style.zIndex = '9997';
    pulse.style.animation = 'pulseExpand 1s ease-out forwards';
    document.body.appendChild(pulse);
    
    setTimeout(() => {
      if (pulse.parentNode) {
        pulse.parentNode.removeChild(pulse);
      }
    }, 1000);
  }

    // Health display management - COMPACT VERSION
    function updateHealthDisplay() {
      const healthUnits = document.getElementById('healthUnits');
      const shieldUnits = document.getElementById('shieldUnits');
      
      if (!healthUnits || !shieldUnits) return;
      
      // Clear existing units
      healthUnits.innerHTML = '';
      shieldUnits.innerHTML = '';
      
      // Create health units - ONLY show current health
      for (let i = 0; i < player.lives; i++) {
        const unit = document.createElement('div');
        unit.className = 'health-unit full';
        healthUnits.appendChild(unit);
      }
      
      // Create shield units - ONLY show current shield
      if (shield > 0) {
        for (let i = 0; i < shield; i++) {
          const unit = document.createElement('div');
          unit.className = 'shield-unit full';
          shieldUnits.appendChild(unit);
        }
      }
    }
  // Animate health damage
  function animateHealthDamage() {
    const healthUnits = document.querySelectorAll('.health-unit.full');
    if (healthUnits.length > 0) {
      const lastUnit = healthUnits[healthUnits.length - 1];
      lastUnit.classList.add('damage-flash');
      
      setTimeout(() => {
        lastUnit.classList.remove('damage-flash');
      }, 300);
    }
  }

  // Animate shield damage
  function animateShieldDamage() {
    const shieldUnits = document.querySelectorAll('.shield-unit.full');
    if (shieldUnits.length > 0) {
      const lastUnit = shieldUnits[shieldUnits.length - 1];
      lastUnit.classList.add('damage-flash');
      
      setTimeout(() => {
        lastUnit.classList.remove('damage-flash');
      }, 300);
    }
  }
  
  // Set hardcore mode hardcore starting hardcore stats - COMPACT VERSION
function setHardcoreStartingStats() {
  // Worse base stats
  player.speed = 210;           // -40 speed
  player.fireRate = 0.3;        // Super slow firing
  player.damageMultiplier = 0.45; //Lower damage multiplier
}

  // Update upgrade chances over time
  function updateUpgradeChances(dt) {
    if (timeAlive >= 100) return;
    
    lastChanceUpdate += dt;
    if (lastChanceUpdate >= 0.5) {
      lastChanceUpdate = 0;
      
      commonChance = Math.max(10, commonChance - 0.1);
      rareChance = Math.min(40, rareChance);
      legendaryChance = Math.min(15, legendaryChance + 0.07);
      mythicalChance = Math.min(10, mythicalChance + 0.03);
    }
  }

  // Activate emergency ability
  function activateEmergencyAbility() {
    emergencyAbilityActive = true;
    
    switch(emergencyAbility) {
      case 'mineLayer':
        minesActive = true;
        mineTimer = 8; // Mines last 8 seconds
        
        const baseMines = 3;
        // Safe check for mineCount stat
        const mineCountLevel = player.stats.mineCount ? player.stats.mineCount.level : 0;
        const extraMines = mineCountLevel * 2;
        const totalMines = baseMines + extraMines;

        // Launch mines in a full circle
        for (let i = 0; i < totalMines; i++) {
          const angle = (i / totalMines) * Math.PI * 2;
          const speed = 150;
          const distance = baseMines * 10 + 10;
          
          const mine = {
            x: player.x + Math.cos(angle) * distance,
            y: player.y + Math.sin(angle) * distance,
            r: 12,
            active: true,
            life: 4.0 + mineCountLevel, // Mines last longer with upgrades
            damage: 1 + mineCountLevel,
            explosionRadius: 75,
            speedX: Math.cos(angle) * speed,
            speedY: Math.sin(angle) * speed,
            pulse: 0,
            color: totalMines > 3 ? (totalMines > 5 ? '#ff5500' : '#ff8800') : '#ffaa00'
          };
          mines.push(mine);
        }        
        emergencyAbilityCooldown = 15;
        sfx(600, 0.1, 0.03, 'square');
        break;        
      case 'shockwave':
        shockwaveDamage = 0.2 + Math.floor(echoesKilled / 12);

        shockwaves.push(new Shockwave(player.x, player.y, shockwaveDamage));
        emergencyAbilityCooldown = 7;
        playSound('shockwave');
        break;
        
      case 'guards':
        const totalRangedGuards = 3 + bossesKilled * 2;
        for (let i = 0; i < totalRangedGuards; i++) {
            const angle = (i / totalRangedGuards) * Math.PI * 2; // Use totalRangedGuards
            const distance = 60 + bossesKilled * 10; // Increased base distance
            const guardX = player.x + Math.cos(angle) * distance;
            const guardY = player.y + Math.sin(angle) * distance;
            guards.push(new Guard(guardX, guardY, 'ranged'));
        }
        
        if (bossesKilled > 0) {
            for (let i = 0; i < bossesKilled; i++) {
                const angle = (i / bossesKilled) * Math.PI * 2;
                const distance = 100 + bossesKilled * 10; // Different distance than ranged guards
                const guardX = player.x + Math.cos(angle) * distance;
                const guardY = player.y + Math.sin(angle) * distance;
                guards.push(new Guard(guardX, guardY, 'melee'));
            }
        }
        guardsActive = true;
        guardsTimer = 20;
        emergencyAbilityCooldown = 35;
        playSound('guards');
        break;
        
      case 'freeze':
        freezeActive = true;
        freezeTimer = 4;
        emergencyAbilityCooldown = 12;
        
        for (const e of echoes) {
          e.frozen = true;
          e.originalSpeed = e.speed;
          e.speed = 0;
        }
        
        freezeOverlay.style.display = 'block';
        playSound('freeze');
        
        for (let i = 0; i < 50; i++) {
          particles.push({
            x: Math.random() * W,
            y: Math.random() * H,
            vx: (Math.random()-0.5)*20,
            vy: (Math.random()-0.5)*20,
            life: 2 + Math.random() * 3,
            col: `rgba(100, 150, 255, 0.7)`,
            r: 2 + Math.random() * 4
          });
        }
        break;
        
      case 'lastResort':
          lastResortActive = true;
          lastResortTimer = 3;
          emergencyAbilityCooldown = player.stats.lastResort.level === 1 ? 15 : 10;
          
          player.invul = 3;
          player.speed *= 1.5;
          playSound('lastResort');
          
          // Reset effect timer
          lastResortEffectTimer = 0;
          
          // Big explosion effect
          spawnParticles(player.x, player.y, 'rgba(255, 255, 100, 0.9)', 50, Math.PI*2, 200);
          spawnParticles(player.x, player.y, 'rgba(255, 200, 0, 0.7)', 30, Math.PI*2, 150);
          break;
        
      case 'saferSpaces':
        saferSpacesActive = true;
        saferSpacesTimer = 10;
        saferSpacesHealth = 5;
        saferSpacesWall = {
          x: player.x,
          y: player.y,
          width: 100,
          height: 100
        };
        emergencyAbilityCooldown = 20;
        playSound('saferSpaces');
        break;
    }
    
    abilityCooldown.style.display = 'block';
  }

  // Update emergency abilities
  function updateEmergencyAbilities(dt) {
    // Update cooldown
    if (emergencyAbilityCooldown > 0) {
      emergencyAbilityCooldown -= dt;
      const maxCooldown = getMaxCooldown();
      const cooldownPercent = 1 - (emergencyAbilityCooldown / maxCooldown);
      abilityCooldownBar.style.width = (cooldownPercent * 100) + '%';
      
      if (emergencyAbilityCooldown <= 0) {
        abilityCooldown.style.display = 'none';
        emergencyAbilityActive = false;
        // Initialize health display
        setTimeout(updateHealthDisplay, 100);
      }
    }
    
    // Update active abilities
    // Update mines
    if (minesActive) {
      mineTimer -= dt;
      
      for (let i = mines.length - 1; i >= 0; i--) {
        const mine = mines[i];
        mine.pulse += dt * 5;
        
        // Initial launch movement
        if (Math.hypot(mine.speedX, mine.speedY) > 10) {
          mine.x += mine.speedX * dt;
          mine.y += mine.speedY * dt;
          mine.speedX *= 0.9; // Slow down
          mine.speedY *= 0.9;
        }
        
        mine.life -= dt;
        
        if (mine.life <= 0) {
          // Mine expires
          spawnParticles(mine.x, mine.y, 'rgba(255,170,0,0.7)', 8, Math.PI*2, 60);
          mines.splice(i, 1);
          continue;
        }
        
        // Check for enemy collisions
        let exploded = false;
        for (let j = echoes.length - 1; j >= 0; j--) {
          const e = echoes[j];
          const d = Math.hypot(mine.x - e.x, mine.y - e.y);
          if (d < mine.r + e.r && mine.active) {
            // Detonate mine
            exploded = true;
            
            // Damage nearby enemies
            for (let k = echoes.length - 1; k >= 0; k--) {
              const enemy = echoes[k];
              const explosionDist = Math.hypot(mine.x - enemy.x, mine.y - enemy.y);
              if (explosionDist < mine.explosionRadius + enemy.r) {
                if (enemy.takeDamage(mine.damage)) {
                  echoesKilled++;
                  spawnParticles(enemy.x, enemy.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
                  echoes.splice(k, 1);
                  echoCountEl.textContent = echoes.length;
                } else {
                  spawnParticles(enemy.x, enemy.y, 'rgba(255,100,0,0.7)', 5, Math.PI/4, 40);
                }
              }
            }
            
            // Explosion effect
            spawnParticles(mine.x, mine.y, 'rgba(255,200,0,0.9)', 25, Math.PI*2, 150);
            spawnParticles(mine.x, mine.y, 'rgba(255,100,0,0.7)', 20, Math.PI*2, 120);
            playSound('rocket');
            shake = 8;
            
            break;
          }
        }
        
        if (exploded) {
          mines.splice(i, 1);
        }
      }
      
      if (mineTimer <= 0 && mines.length === 0) {
        minesActive = false;
      }
    }
    
    if (freezeActive) {
      freezeTimer -= dt;
      
      for (const e of echoes) {
        if (!e.frozen) {
          e.frozen = true;
          e.originalSpeed = e.speed;
          e.speed = 0;
        }
      }
      
      if (Math.random() < 0.1) {
        particles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          vx: (Math.random()-0.5)*10,
          vy: (Math.random()-0.5)*10,
          life: 1 + Math.random() * 2,
          col: `rgba(100, 150, 255, 0.5)`,
          r: 1 + Math.random() * 3
        });
      }
      
      if (freezeTimer <= 0) {
        freezeActive = false;
        freezeOverlay.style.display = 'none';
        
        for (const e of echoes) {
          if (e.originalSpeed !== undefined) {
            e.speed = e.originalSpeed;
            e.frozen = false;
          }
        }
      }
    }
    
      if (lastResortActive) {
          lastResortTimer -= dt;
          lastResortEffectTimer += dt;
          
          // Create a pulsing energy field around player
          if (Math.random() < 0.5) {
              const angle = Math.random() * Math.PI * 2;
              const distance = player.r * (2 + Math.sin(lastResortEffectTimer * 8) * 0.5);
              particles.push({
                  x: player.x + Math.cos(angle) * distance,
                  y: player.y + Math.sin(angle) * distance,
                  vx: (Math.random()-0.5)*40,
                  vy: (Math.random()-0.5)*40,
                  life: 0.3 + Math.random() * 0.3,
                  col: `rgba(255, 255, ${50 + Math.random()*150}, 0.8)`,
                  r: 3 + Math.random() * 3
              });
          }
          
          // Golden trail effect
          if (Math.random() < 0.4) {
              player.trail.push({
                  x: player.x,
                  y: player.y,
                  life: 0.4,
                  alpha: 0.6
              });
              if (player.trail.length > 12) player.trail.shift();
          }
          
          if (lastResortTimer <= 0) {
              lastResortActive = false;
              player.speed /= 1.5;
              
              // End explosion
              spawnParticles(player.x, player.y, 'rgba(255, 200, 100, 0.9)', 30, Math.PI*2, 180);
              shake = 8;
          }
      }
    
    if (guardsActive) {
      guardsTimer -= dt;
      
      for (let i = guards.length - 1; i >= 0; i--) {
        if (!guards[i].update(dt)) {
          guards.splice(i, 1);
        }
      }
      
      if (guardsTimer <= 0 && guards.length === 0) {
        guardsActive = false;
      }
    }
    
    for (let i = shockwaves.length - 1; i >= 0; i--) {
      if (!shockwaves[i].update(dt)) {
        shockwaves[i].cleanup();
        shockwaves.splice(i, 1);
        shockwaveActive = false;
      }
    }
    
    // Auto-activate shockwave when cooldown is over
    if (emergencyAbility === 'shockwave' && emergencyAbilityCooldown <= 0 && !emergencyAbilityActive) {
      shockwaveDamage = 0.2 + Math.floor(echoesKilled / 12);
      shockwaves.push(new Shockwave(player.x, player.y, shockwaveDamage));
      emergencyAbilityCooldown = 7;
      playSound('shockwave');
    }

    // Update safer spaces
    if (saferSpacesActive) {
      saferSpacesTimer -= dt;
      saferSpacesWall.x = player.x;
      saferSpacesWall.y = player.y;
      
      // Check for enemy collisions with the wall
      for (let i = echoes.length - 1; i >= 0; i--) {
        const e = echoes[i];
        const wallLeft = saferSpacesWall.x - saferSpacesWall.width/2;
        const wallRight = saferSpacesWall.x + saferSpacesWall.width/2;
        const wallTop = saferSpacesWall.y - saferSpacesWall.height/2;
        const wallBottom = saferSpacesWall.y + saferSpacesWall.height/2;
        
        if (e.x + e.r > wallLeft && e.x - e.r < wallRight &&
            e.y + e.r > wallTop && e.y - e.r < wallBottom) {
          // Don't kill bosses with safer spaces
          if (!(e instanceof EasyBoss || e instanceof MediumBoss || e instanceof HardBoss || e instanceof FinalBoss || e instanceof MegaCreeperBoss)) {
            saferSpacesHealth--;
            spawnParticles(e.x, e.y, 'rgba(255,255,255,0.9)', 10, Math.PI*2, 80);
            echoes.splice(i, 1);
            echoesKilled++;
          }
          
          if (saferSpacesHealth <= 0) {
            saferSpacesActive = false;
            break;
          }
        }
      }
      
      // Block ENEMY bullets with safer spaces (player bullets can pass through)
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        const wallLeft = saferSpacesWall.x - saferSpacesWall.width/2;
        const wallRight = saferSpacesWall.x + saferSpacesWall.width/2;
        const wallTop = saferSpacesWall.y - saferSpacesWall.height/2;
        const wallBottom = saferSpacesWall.y + saferSpacesWall.height/2;
        
        // Check if bullet is inside the safer spaces wall
        if (b.x > wallLeft && b.x < wallRight && b.y > wallTop && b.y < wallBottom) {
          // Only block enemy bullets, let player bullets pass through
          if (b.enemy) {
            bullets.splice(i, 1);
            spawnParticles(b.x, b.y, 'rgba(0,255,255,0.7)', 5, Math.PI*2, 40);
            
            // FIX: Reduce health when blocking bullets
            saferSpacesHealth--;
            
            if (saferSpacesHealth <= 0) {
              saferSpacesActive = false;
              saferSpacesWall = null;
              break;
            }
          }
        }
      }
      
      // FIX: Check if timer expired
      if (saferSpacesTimer <= 0) {
        saferSpacesActive = false;
        saferSpacesWall = null;
      }
    }

    // Update minigun
    if (minigunActive) {
      minigunTimer += dt;
      const fireRate = player.stats.minigun.level === 1 ? 0.4 :
                      player.stats.minigun.level === 2 ? 0.25 :
                      player.stats.minigun.level === 3 ? 0.15 :
                      player.stats.minigun.level === 4 ? 0.1 : 0.05;
      
      if (minigunTimer >= fireRate) {
        minigunTimer = 0;
        fireMinigunBullet();
      }
    }
  }

  // Get max cooldown for current ability
  function getMaxCooldown() {
    switch(emergencyAbility) {
      case 'mineLayer': return 15;
      case 'shockwave': return 7;
      case 'guards': return 35;
      case 'freeze': return 30;
      case 'lastResort': return 20;
      case 'saferSpaces': return 30;
      default: return 15;
    }
  }

      // LightningStrike class
    class LightningStrike {
      constructor(x, y, damage) {
        this.x = x;
        this.y = y;
        this.damage = 2 * player.damageMultiplier; // Base damage multiplied
        this.chainCount = 0;
        this.maxChain = 2 + (player.stats.bulletLife.level * 2);
        this.targets = [];
        this.completed = false;
        this.timer = 0;
        this.maxTime = 0.5 + (player.stats.bulletLife.level * 0.2);
        this.segments = [];
        this.particles = [];
        this.findFirstTarget();
      }
      
      findFirstTarget() {
        // Find closest enemy
        let nearest = null;
        let nearestDist = Infinity;
        
        for (const e of echoes) {
          const d = dist({x: this.x, y: this.y}, e);
          if (d < nearestDist && !this.targets.includes(e)) {
            nearest = e;
            nearestDist = d;
          }
        }
        
        if (nearest) {
          this.targets.push(nearest);
          this.segments.push({
            startX: this.x,
            startY: this.y,
            endX: nearest.x,
            endY: nearest.y
          });
          this.applyDamage(nearest);
          this.chainCount = 1;
          
          // Create initial lightning particles
          this.createLightningParticles(this.x, this.y, nearest.x, nearest.y);
        } else {
          this.completed = true;
        }
      }
      
      applyDamage(enemy) {
        const chainMultiplier = Math.max(0.1, 1 - (this.chainCount - 1) * 0.10); // 10% less per chain
        const finalDamage = this.damage * chainMultiplier;
        
        if (enemy.takeDamage(finalDamage)) {
          echoesKilled++;

              // === ADD THIS SECTION FOR XP ===
              // Give 15 XP for lightning kill (same as regular kills)
              let baseXP = 15;
              let xpMultiplier = 1;
              
              if (player.stats.xpBoost.level >= 1) {
                baseXP = 25; // Level 1: +10 XP
              }
              if (player.stats.xpBoost.level >= 2) {
                xpMultiplier = 1.5; // Level 2: +50%
              }
              if (player.stats.xpBoost.level >= 5) {
                xpMultiplier *= 1.5; // Level 5: Additional 50%
              }
              
              playerXP += baseXP * xpMultiplier;
              checkLevelUp();
              // === END XP SECTION ===


          if (gameMode !== 'freemode' || player.lives > 0) {
            score += 8;
          }
          spawnParticles(enemy.x, enemy.y, 'rgba(255,255,200,0.9)', 16, Math.PI*2, 120);
          
          const index = echoes.indexOf(enemy);
          if (index > -1) {
            echoes.splice(index, 1);
            echoCountEl.textContent = echoes.length;
          }
        } else {
          spawnParticles(enemy.x, enemy.y, 'rgba(255,255,200,0.7)', 5, Math.PI/4, 40);
        }
        
        // Lightning sound effect
        sfx(1200 - (this.chainCount * 100), 0.1, 0.03, 'sawtooth');
        
        // Screen flash for hit
        if (this.chainCount === 1) {
          createScreenFlash('rgba(255,255,200,0.2)', 0.1);
        }
      }
      
      findNextTarget() {
        if (this.chainCount >= this.maxChain || echoes.length === 0) {
          this.completed = true;
          return;
        }
        
        const lastTarget = this.targets[this.targets.length - 1];
        let nearest = null;
        let nearestDist = Infinity;
        
        for (const e of echoes) {
          if (!this.targets.includes(e)) {
            const d = dist({x: lastTarget.x, y: lastTarget.y}, e);
            if (d < nearestDist && d < 200 + (player.stats.bulletLife.level * 50)) { // Max bounce range
              nearest = e;
              nearestDist = d;
            }
          }
        }
        
        if (nearest) {
          this.targets.push(nearest);
          this.chainCount++;
          
          this.segments.push({
            startX: lastTarget.x,
            startY: lastTarget.y,
            endX: nearest.x,
            endY: nearest.y
          });
          
          this.applyDamage(nearest);
          this.createLightningParticles(lastTarget.x, lastTarget.y, nearest.x, nearest.y);
        } else {
          this.completed = true;
        }
      }
      
      createLightningParticles(startX, startY, endX, endY) {
        const segmentLength = Math.hypot(endX - startX, endY - startY);
        const numParticles = Math.max(5, Math.floor(segmentLength / 10));
        
        for (let i = 0; i < numParticles; i++) {
          const t = i / (numParticles - 1);
          const particleX = startX + (endX - startX) * t;
          const particleY = startY + (endY - startY) * t;
          
          // Add slight offset for lightning effect
          const offsetX = (Math.random() - 0.5) * 20;
          const offsetY = (Math.random() - 0.5) * 20;
          
          this.particles.push({
            x: particleX + offsetX,
            y: particleY + offsetY,
            life: 0.3 + Math.random() * 0.2,
            size: 2 + Math.random() * 3,
            color: `rgba(255, ${255 - this.chainCount * 20}, ${150 - this.chainCount * 30}, 1)`
          });
        }
      }
      
      update(dt) {
        this.timer += dt;
        
        // Find next target if needed
        if (!this.completed && this.timer > 0.1 * this.chainCount) {
          this.findNextTarget();
        }
        
        // Update particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
          this.particles[i].life -= dt;
          if (this.particles[i].life <= 0) {
            this.particles.splice(i, 1);
          }
        }
        
        return this.timer < this.maxTime && !this.completed;
      }
      
      draw(ctx) {
        // Draw lightning segments
        for (const segment of this.segments) {
          this.drawLightningSegment(ctx, segment.startX, segment.startY, segment.endX, segment.endY);
        }
        
        // Draw particles
        for (const particle of this.particles) {
          const alpha = particle.life / 0.5;
          ctx.beginPath();
          ctx.fillStyle = particle.color.replace('1)', `${alpha})`);
          ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
          ctx.fill();
          
          // Glow effect
          const glowGradient = ctx.createRadialGradient(
            particle.x, particle.y, 1,
            particle.x, particle.y, particle.size * 3
          );
          glowGradient.addColorStop(0, particle.color.replace('1)', `${alpha * 0.5})`));
          glowGradient.addColorStop(1, particle.color.replace('1)', '0)'));
          
          ctx.beginPath();
          ctx.fillStyle = glowGradient;
          ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw impact effects on targets
        for (const target of this.targets) {
          const pulse = Math.sin(this.timer * 20) * 0.3 + 0.7;
          const glowGradient = ctx.createRadialGradient(
            target.x, target.y, 1,
            target.x, target.y, target.r * 2
          );
          glowGradient.addColorStop(0, `rgba(255, 255, 200, ${pulse * 0.3})`);
          glowGradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
          
          ctx.beginPath();
          ctx.fillStyle = glowGradient;
          ctx.arc(target.x, target.y, target.r * 2, 0, Math.PI * 2);
          ctx.fill();

          // ===== ADD THE LEVEL 2 EFFECT RIGHT HERE =====
          if (player.stats.lightningStrike.level >= 2) {
            // Level 2: Add crackling electricity around hit enemies
            const crackleRadius = target.r * (1.5 + Math.sin(this.timer * 30) * 0.5);
            ctx.beginPath();
            ctx.strokeStyle = `rgba(255, 255, 100, ${pulse * 0.5})`;
            ctx.lineWidth = 2;

            // Create jagged circle effect
            const cracklePoints = 8;
            for (let i = 0; i < cracklePoints; i++) {
              const angle = (i / cracklePoints) * Math.PI * 2 + this.timer * 5;
              const offset = Math.random() * 10;
              const crackleX = target.x + Math.cos(angle) * (crackleRadius + offset);
              const crackleY = target.y + Math.sin(angle) * (crackleRadius + offset);
              
              if (i === 0) ctx.moveTo(crackleX, crackleY);
              else ctx.lineTo(crackleX, crackleY);
            }
            ctx.closePath();
            ctx.stroke();
          }
          // ===== END LEVEL 2 EFFECT =====
        }
      }
      
      drawLightningSegment(ctx, startX, startY, endX, endY) {
        const segmentLength = Math.hypot(endX - startX, endY - startY);
        const numJags = Math.max(3, Math.floor(segmentLength / 20));
        
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        
        // Create jagged lightning path
        for (let i = 1; i <= numJags; i++) {
          const t = i / numJags;
          const midX = startX + (endX - startX) * t;
          const midY = startY + (endY - startY) * t;
          
          // Add jagged offset
          const offsetX = (Math.random() - 0.5) * 15;
          const offsetY = (Math.random() - 0.5) * 15;
          
          ctx.lineTo(midX + offsetX, midY + offsetY);
        }
        
        ctx.lineTo(endX, endY);
        
        // Main lightning bolt
        ctx.strokeStyle = `rgba(255, 255, ${200 - this.chainCount * 20}, 0.9)`;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.stroke();
        
        // Glow effect
        ctx.strokeStyle = `rgba(255, 255, 100, 0.4)`;
        ctx.lineWidth = 8;
        ctx.stroke();
        
        // Core glow
        ctx.strokeStyle = `rgba(255, 255, 255, 0.8)`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        ctx.restore();
      }
    }

  // Fire minigun bullet
  function fireMinigunBullet() {
    let aim;
    if (player.autoAim) {
      let nearest = null;
      let nearestDist = Infinity;
      for (const e of echoes) {
        const d = dist({x: player.x, y: player.y}, e);
        if (d < nearestDist) {
          nearest = e;
          nearestDist = d;
        }
      }
      if (nearest) {
        aim = vecTo(player.x, player.y, nearest.x, nearest.y);
      } else {
        aim = {x: 1, y: 0};
      }
    } else {
      aim = vecTo(player.x, player.y, input.mx, input.my);
    }
    
    const inaccuracy = (Math.random() - 0.5) * 0.25;
    const angle = Math.atan2(aim.y, aim.x) + inaccuracy;
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);
    
    //minigun bullets
    minigunBullets.push({
      x: player.x,
      y: player.y,
      dx: dx,
      dy: dy,
      life: player.bulletLife * 1 + 0.3,
      speed: player.bulletSpeed * 1,
      size: 7 + player.stats.bulletSize.level * 2,
      damage: 0.35 * player.damageMultiplier,
      minigun: true
    });
    
    playSound('sawtooth');
    spawnParticles(player.x, player.y, 'rgba(255,200,100,0.9)', 3, Math.PI/4, 30);
  }

  // Update minigun bullets
  function updateMinigunBullets(dt) {
    for (let i = minigunBullets.length - 1; i >= 0; i--) {
      const b = minigunBullets[i];
      b.life -= dt;
      
      b.x += b.dx * b.speed * dt;
      b.y += b.dy * b.speed * dt;
      
      if (b.x < -50 || b.x > W+50 || b.y < -50 || b.y > H+50 || b.life <= 0) {
        minigunBullets.splice(i, 1);
        continue;
      }
      
      for (let j = echoes.length - 1; j >= 0; j--) {
        const e = echoes[j];
        const d = Math.hypot(b.x - e.x, b.y - e.y);
        if (d < e.r + b.size) {
          
              if (b.piercing && b.piercedEnemies && !b.piercedEnemies.includes(e)) {
          b.piercedEnemies.push(e);
          if (b.piercedEnemies.length >= b.maxPierces) {
            bullets.splice(i,1);
            spawnParticles(b.x, b.y, 'rgba(170,255,255,0.9)', 15, Math.PI*2, 80);
            break;
          }
        }

          if (e.takeDamage(b.damage)) {
            echoesKilled++;
            spawnParticles(e.x, e.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
            echoes.splice(j, 1);
          }
          
          // Apply knockback to minigun bullets (1/4 of regular knockback)
          if (player.stats.knockbackBullets.level > 0 && b.minigun) {
            const knockbackForce = (player.stats.knockbackBullets.level === 1 ? 30 : 
                                  player.stats.knockbackBullets.level === 2 ? 60 : 100) * 0.25; // 1/4 knockback
            const toEnemy = vecTo(player.x, player.y, e.x, e.y);
            
            e.knockbackX = toEnemy.x * knockbackForce;
            e.knockbackY = toEnemy.y * knockbackForce;
            e.knockbackTimer = 0.25; // 1/4 the time of regular bullets
          }
          
          minigunBullets.splice(i, 1);
          break;
        }
      }
    }
  }

  // Shockwave class
  class Shockwave {
    constructor(x, y, damage) {
      this.x = x;
      this.y = y;
      this.radius = 0;
      this.maxRadius = player.r * 30;
      this.duration = 1;
      this.timer = 0;
      this.damage = damage;
      this.damageTimer = 0;
      this.frozenEnemies = [];
    }
    
    update(dt) {
      this.timer += dt;
      this.damageTimer += dt;
      
      this.radius = (this.timer / this.duration) * this.maxRadius;
      
      if (this.damageTimer >= 0.2) {
        this.damageTimer = 0;
        
        for (const e of echoes) {
          const d = dist({x: this.x, y: this.y}, e);
          if (d < this.radius + e.r) {
            if (!this.frozenEnemies.includes(e)) {
              this.frozenEnemies.push(e);
              e.frozen = true;
              e.originalSpeed = e.speed;
              e.speed = 0;
            }
            
            if (e.takeDamage(this.damage)) {
              echoesKilled++;
              spawnParticles(e.x, e.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
              const index = echoes.indexOf(e);
              if (index > -1) {
                echoes.splice(index, 1);
              }
            }
          }
        }
      }
      
      if (Math.random() < 0.3) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * this.radius;
        const particleX = this.x + Math.cos(angle) * distance;
        const particleY = this.y + Math.sin(angle) * distance;
        
        particles.push({
          x: particleX,
          y: particleY,
          vx: (Math.random()-0.5)*40,
          vy: (Math.random()-0.5)*40,
          life: 0.5 + Math.random() * 0.5,
          col: `rgba(100, 200, 255, 0.8)`,
          r: 2 + Math.random() * 3
        });
      }
      
      return this.timer < this.duration;
    }
    
    draw(ctx) {
      const alpha = 1 - (this.timer / this.duration);
      const pulse = Math.sin(this.timer * 10) * 0.2 + 0.8;
      
      const g = ctx.createRadialGradient(this.x, this.y, this.radius * 0.5, this.x, this.y, this.radius);
      g.addColorStop(0, `rgba(100, 200, 255, ${alpha * 0.3})`);
      g.addColorStop(1, `rgba(50, 100, 255, ${alpha * 0.1})`);
      
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      
      ctx.strokeStyle = `rgba(100, 200, 255, ${alpha * 0.7})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.stroke();
      
      ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI*2);
      ctx.stroke();
      
      for (let i = 0; i < 8; i++) {
        const startAngle = (i / 8) * Math.PI * 2;
        const endAngle = startAngle + Math.PI / 8;
        const startX = this.x + Math.cos(startAngle) * this.radius * 0.9;
        const startY = this.y + Math.sin(startAngle) * this.radius * 0.9;
        const endX = this.x + Math.cos(endAngle) * this.radius * 1.1;
        const endY = this.y + Math.sin(endAngle) * this.radius * 1.1;
        
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }
    }
    
    cleanup() {
      for (const e of this.frozenEnemies) {
        if (e.originalSpeed !== undefined) {
          e.speed = e.originalSpeed;
          e.frozen = false;
        }
      }
    }
  }

  // Guard class - IMPROVED LOOKS
  class Guard {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.type = type;
      this.r = type === 'ranged' ? 12 : 8; //Size
      this.life = 25;
      this.maxLife = 25;
      this.speed = type === 'ranged' ? 0 : 250;
      this.color = type === 'ranged' ? '#ffabf7' : '#ff4acc';
      this.target = null;
      this.fireTimer = 0;
      this.fireCooldown = type === 'ranged' ? 0.5 : 1; // Ranged: half reload speed
      this.meleeDamageTimer = 0;
      this.alpha = 1;
      this.fadeTimer = 19;
      this.pulse = 0;
    }
    
    update(dt) {
      this.life -= dt;
      this.fireTimer += dt;
      this.meleeDamageTimer += dt;
      this.fadeTimer -= dt;
      this.pulse += dt * 5;
      
      if (this.fadeTimer <= 0) {
        this.alpha = Math.max(0, this.alpha - dt);
      }
      
      if (this.alpha <= 0) return false;

      
      
      if (!this.target || this.target.health <= 0) {
        let nearestDist = Infinity;
        this.target = null;
        for (const e of echoes) {
          const d = dist({x: this.x, y: this.y}, e);
          if (d < nearestDist) {
            nearestDist = d;
            this.target = e;
          }
        }
      }
      
      if (this.target) {
        const toTarget = vecTo(this.x, this.y, this.target.x, this.target.y);
        this.x += toTarget.x * this.speed * dt;
        this.y += toTarget.y * this.speed * dt;
        
        if (this.type === 'ranged' && this.fireTimer >= this.fireCooldown) {
          this.fireTimer = 0;
          this.shoot();
        }
        
        if (this.type === 'melee') {
          const d = dist({x: this.x, y: this.y}, this.target);
          if (d < this.r + this.target.r && this.meleeDamageTimer >= 1) {
            this.meleeDamageTimer = 0;
            this.target.takeDamage(3);
            spawnParticles(this.target.x, this.target.y, 'rgba(255,100,100,0.9)', 8, Math.PI*2, 60);
          }
        }
      }
      
      return this.life > 0;
    }
    
    shoot() {
      if (!this.target) return;
      
      const aim = vecTo(this.x, this.y, this.target.x, this.target.y);
      bullets.push({
        x: this.x,
        y: this.y,
        dx: aim.x,
        dy: aim.y,
        t: 0,
        life: 1.5,
        speed: 400,
        size: 5,
        color: '#4dabf7',
        damage: 1
      });
      
      sfx(800, 0.05, 0.015, 'sine');
      spawnParticles(this.x, this.y, 'rgba(77,171,247,0.9)', 5, Math.PI/4, 40);
    }
    
    draw(ctx) {
      ctx.globalAlpha = this.alpha;
      
      const pulseSize = 1 + Math.sin(this.pulse) * 0.1;
      
      // Improved guard appearance with glow
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.r*3);
      g.addColorStop(0, this.color + 'DD');
      g.addColorStop(1, this.color + '11');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*3, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r * pulseSize, 0, Math.PI*2);
      ctx.fill();
      
      if (this.type === 'ranged') {
        // Improved bow appearance
        ctx.strokeStyle = '#2d7fcc';
        ctx.lineWidth = 4;
        const bowLength = this.r * 1.2;
        const bowAngle = Math.PI / 6;
        
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(
          this.x + Math.cos(bowAngle) * bowLength,
          this.y + Math.sin(bowAngle) * bowLength
        );
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(
          this.x + Math.cos(-bowAngle) * bowLength,
          this.y + Math.sin(-bowAngle) * bowLength
        );
        ctx.stroke();
        
        // Bow string
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(
          this.x + Math.cos(bowAngle) * bowLength * 0.8,
          this.y + Math.sin(bowAngle) * bowLength * 0.8
        );
        ctx.lineTo(
          this.x + Math.cos(-bowAngle) * bowLength * 0.8,
          this.y + Math.sin(-bowAngle) * bowLength * 0.8
        );
        ctx.stroke();
      } else {
        // Improved sword appearance
        ctx.strokeStyle = '#8b0000';
        ctx.lineWidth = 6;
        const swordLength = this.r * 1.5;
        
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(
          this.x + Math.cos(0) * swordLength,
          this.y + Math.sin(0) * swordLength
        );
        ctx.stroke();
        
        // Sword hilt
        ctx.fillStyle = '#8b0000';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r * 0.4, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Eyes
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.beginPath();
      ctx.arc(this.x - this.r*0.3, this.y, this.r*0.15, 0, Math.PI*2);
      ctx.arc(this.x + this.r*0.3, this.y, this.r*0.15, 0, Math.PI*2);
      ctx.fill();
      
      ctx.globalAlpha = 1;
    }
  }

  // Fire class
  class Fire {
    constructor(x, y, width, duration, damage) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.duration = duration;
      this.maxDuration = duration;
      this.damage = damage;
      this.damageTimer = 0;
      this.pulse = 0;
    }
    
    update(dt) {
      this.duration -= dt;
      this.damageTimer += dt;
      this.pulse += dt * 5;
      
      if (this.damageTimer >= 0.5) {
        this.damageTimer = 0;
        for (const e of echoes) {
          const d = dist({x: this.x, y: this.y}, e);
          if (d < this.width) {
            if (e.takeDamage(this.damage)) {
              echoesKilled++;
              spawnParticles(e.x, e.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
              const index = echoes.indexOf(e);
              if (index > -1) {
                echoes.splice(index, 1);
              }
            } else {
              spawnParticles(e.x, e.y, 'rgba(255, 100, 0, 0.7)', 3, Math.PI/4, 30);
            }
          }
        }
      }
      
      return this.duration > 0;
    }
    
    draw(ctx) {
      const alpha = this.duration / this.maxDuration;
      const pulseSize = 1 + Math.sin(this.pulse) * 0.1;
      
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.width * pulseSize);
      g.addColorStop(0, `rgba(255, 100, 0, ${alpha * 0.8})`);
      g.addColorStop(0.3, `rgba(255, 150, 0, ${alpha * 0.6})`);
      g.addColorStop(0.7, `rgba(255, 200, 0, ${alpha * 0.4})`);
      g.addColorStop(1, `rgba(255, 50, 0, ${alpha * 0.2})`);
      
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.width * pulseSize, 0, Math.PI*2);
      ctx.fill();
      
      if (Math.random() < 0.3) {
        const flickerSize = this.width * (0.8 + Math.random() * 0.4);
        ctx.fillStyle = `rgba(255, 200, 0, ${alpha * 0.3})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, flickerSize, 0, Math.PI*2);
        ctx.fill();
      }
      
      if (Math.random() < 0.4) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * this.width * 0.8;
        const particleX = this.x + Math.cos(angle) * distance;
        const particleY = this.y + Math.sin(angle) * distance;
        
        particles.push({
          x: particleX,
          y: particleY,
          vx: (Math.random()-0.5)*20,
          vy: -Math.random()*30,
          life: 0.5 + Math.random() * 0.5,
          col: `rgba(255, ${150 + Math.random()*100}, 0, ${alpha * 0.8})`,
          r: 2 + Math.random() * 3
        });
      }
    }
  }

  // FirePulse class
  class FirePulse {
    constructor(x, y, angle) {
      this.x = x;
      this.y = y;
      this.angle = angle;
      this.speed = 500;
      this.life = 1;
      this.damage = 0.25;
      this.width = player.stats.fire.level === 1 ? 30 : 40;
      this.duration = player.stats.fire.level === 1 ? 2 : 3;
    }
    
    update(dt) {
      this.life -= dt;
      
      this.x += Math.cos(this.angle) * this.speed * dt;
      this.y += Math.sin(this.angle) * this.speed * dt;
      
      fires.push(new Fire(this.x, this.y, this.width, this.duration, this.damage));
      
      for (let i = echoes.length - 1; i >= 0; i--) {
        const e = echoes[i];
        const d = dist({x: this.x, y: this.y}, e);
        if (d < this.width/2 + e.r) {
          if (e.takeDamage(this.damage)) {
            echoesKilled++;
            spawnParticles(e.x, e.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
            echoes.splice(i, 1);
          } else {
            spawnParticles(e.x, e.y, 'rgba(255, 100, 0, 0.7)', 5, Math.PI/4, 40);
          }
        }
      }
      
      if (Math.random() < 0.7) {
        particles.push({
          x: this.x,
          y: this.y,
          vx: (Math.random()-0.5)*40,
          vy: (Math.random()-0.5)*40,
          life: 0.3 + Math.random() * 0.4,
          col: `rgba(255, ${100 + Math.random()*100}, 0, 0.8)`,
          r: 3 + Math.random() * 4
        });
      }
      
      return this.life > 0;
    }
    
    draw(ctx) {
      const alpha = this.life / 1.5;
      const size = 15 + Math.sin(performance.now() * 0.01) * 5;
      
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, size*2);
      g.addColorStop(0, `rgba(255, 100, 0, ${alpha * 0.9})`);
      g.addColorStop(1, `rgba(255, 200, 0, ${alpha * 0.3})`);
      
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, size, 0, Math.PI*2);
      ctx.fill();
      
      ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.7})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, size * 0.7, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  // Rocket class
  class Rocket {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.r = 8;
      this.speed = 400;
      this.life = 3;
      this.damage = 0.4; 
      this.damageTimer = 0;
      this.target = null;
      this.color = '#ff6b6b';
      this.trail = [];
    }
    
    update(dt) {
      this.life -= dt;
      this.damageTimer += dt;
      
      this.trail.push({x: this.x, y: this.y});
      if (this.trail.length > 10) this.trail.shift();
      
      if (!this.target || this.target.health <= 0) {
        let maxHealth = 0;
        this.target = null;
        for (const e of echoes) {
          if (e.health > maxHealth) {
            maxHealth = e.health;
            this.target = e;
          }
        }
      }
      
      if (this.target) {
        const aim = vecTo(this.x, this.y, this.target.x, this.target.y);
        this.x += aim.x * this.speed * dt;
        this.y += aim.y * this.speed * dt;
        
        const d = dist({x: this.x, y: this.y}, this.target);
        if (d < this.r + this.target.r) {
          this.target.takeDamage(this.damage);
          if (player.stats.rocket.level >= 2) {
            this.target.rocketDamage = (this.target.rocketDamage || 0) + 3; // INCREASED: From 2 to 3
          }
          spawnParticles(this.x, this.y, 'rgba(255,100,100,0.9)', 15, Math.PI*2, 100);
          return false;
        }
      } else {
        this.x += Math.cos(0) * this.speed * dt;
        this.y += Math.sin(0) * this.speed * dt;
      }
      
      // Increase damage faster with new speed
      if (this.damageTimer >= 0.2) { // Reduced from 0.5 to 0.2
        this.damageTimer = 0;
        this.damage += 0.1; // Decreased from 1.5 to 0.25
        // Scale rocket size with damage
        this.r = 8 + (this.damage - 5) * 0.5;
      }
      
      if (this.x < -100 || this.x > W+100 || this.y < -100 || this.y > H+100 || this.life <= 0) {
        spawnParticles(this.x, this.y, 'rgba(255,100,100,0.9)', 10, Math.PI*2, 80);
        return false;
      }
      
      return true;
    }
    
    draw(ctx) {
      for (let i = 0; i < this.trail.length; i++) {
        const point = this.trail[i];
        const alpha = i / this.trail.length * 0.5;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,100,100,${alpha})`;
        ctx.arc(point.x, point.y, this.r * (i / this.trail.length), 0, Math.PI*2);
        ctx.fill();
      }
      
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.r*3);
      g.addColorStop(0, 'rgba(255,100,100,0.8)');
      g.addColorStop(1, 'rgba(255,50,50,0.1)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Spawn indicator class
  class SpawnIndicator {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.type = type;
      this.life = 2.0;
      this.maxLife = 2.0;
      this.size = 30;
    }
    
    update(dt) {
      this.life -= dt;
      return this.life > 0;
    }
    
    draw(ctx) {
      const alpha = this.life / this.maxLife;
      const pulse = Math.sin(this.life * 10) * 0.3 + 0.7;
      
      ctx.globalAlpha = alpha;
      
      let color;
      switch(this.type) {
        case 'slim': color = '#ff9500'; break;
        case 'tank': color = '#8b4513'; break;
        case 'bow': color = '#4dabf7'; break;
        case 'witch': color = '#a78bfa'; break;
        case 'sniper': color = '#8a2be2'; break;
        case 'bomber': color = '#006400'; break;
        case 'armoredSlim': color = '#ff4500'; break;
        default: color = '#ff6b6b';
      }
      
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI*2);
      ctx.stroke();
      
      const angle = Math.atan2(H/2 - this.y, W/2 - this.x);
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(
        this.x + Math.cos(angle) * this.size * 0.7,
        this.y + Math.sin(angle) * this.size * 0.7
      );
      ctx.stroke();
      
      ctx.globalAlpha = 1;
    }
  }

  // Slim enemy class
  class Slim {
    constructor(spawnX, spawnY) {
      this.x = spawnX;
      this.y = spawnY;
      this.r = 8;
      this.health = 1;
      this.maxHealth = 1;
      this.speed = 30;
      this.color = '#ff9500';
      this.age = 0;
      this.isFriendly = false;
      this.frozen = false;
      this.originalSpeed = 30;
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.age += dt;
      
      let targetX, targetY;
      if (this.isFriendly) {
        let nearestEnemy = null;
        let nearestDist = Infinity;
        for (const e of echoes) {
          if (e !== this && !(e instanceof Slim && e.isFriendly)) {
            const d = dist({x: this.x, y: this.y}, e);
            if (d < nearestDist) {
              nearestEnemy = e;
              nearestDist = d;
            }
          }
        }
        if (nearestEnemy) {
          targetX = nearestEnemy.x;
          targetY = nearestEnemy.y;
        } else {
          targetX = player.x;
          targetY = player.y;
        }
      } else {
        targetX = player.x;
        targetY = player.y;
      }
      
      const toTarget = vecTo(this.x, this.y, targetX, targetY);
      this.x += toTarget.x * this.speed * dt;
      this.y += toTarget.y * this.speed * dt;
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
      
      if (this.isFriendly) {
        for (const e of echoes) {
          if (e !== this && !(e instanceof Slim && e.isFriendly)) {
            const d = dist({x: this.x, y: this.y}, e);
            if (d < this.r + e.r) {
              e.takeDamage(this.damage || 1);
              this.health = 0;
              break;
            }
          }
        }
      }
      
      return this.health > 0;
    }
    
    draw(ctx) {
      ctx.beginPath();
      ctx.fillStyle = this.isFriendly ? '#7ee787' : this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.arc(this.x - this.r*0.3, this.y, this.r*0.2, 0, Math.PI*2);
      ctx.arc(this.x + this.r*0.3, this.y, this.r*0.2, 0, Math.PI*2);
      ctx.fill();
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(255,149,0,0.9)', 5, Math.PI*2, 40);
      return this.health <= 0;
    }
  }

  // NEW: Armored Slim enemy class
  class ArmoredSlim {
    constructor(spawnX, spawnY) {
      this.x = spawnX;
      this.y = spawnY;
      this.r = 13; // bigger than regular slim
      this.health = 1 + echoesKilled * 0.2; // Scales with echoes killed
      this.maxHealth = 50;
      this.speed = 40; // faster than regular slim
      this.color = '#ff4500';
      this.age = 0;
      this.isFriendly = false;
      this.frozen = false;
      this.originalSpeed = 40;
      this.healTimer = 0;
    }

    
    update(dt) {
      if (this.frozen) return true;
      
      this.age += dt;
      this.healTimer += dt;
      
      // Heal 2 HP every second
      if (this.healTimer >= 0.5 && this.health < this.maxHealth) {
        this.healTimer = 0;
        this.health = Math.min(this.maxHealth, this.health + 1);
        spawnParticles(this.x, this.y, 'rgba(0,255,0,0.7)', 3, Math.PI*2, 20);
      }
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt;
      this.y += toPlayer.y * this.speed * dt;
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
      
      return this.health > 0;
    }
    
    draw(ctx) {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      // Armor plating
      ctx.strokeStyle = '#8b0000';
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        const plateX = this.x + Math.cos(angle) * this.r * 0.7;
        const plateY = this.y + Math.sin(angle) * this.r * 0.7;
        ctx.beginPath();
        ctx.arc(plateX, plateY, this.r * 0.3, 0, Math.PI*2);
        ctx.stroke();
      }
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.arc(this.x - this.r*0.3, this.y, this.r*0.2, 0, Math.PI*2);
      ctx.arc(this.x + this.r*0.3, this.y, this.r*0.2, 0, Math.PI*2);
      ctx.fill();
      
      // Health bar
      const barWidth = this.r * 1.5;
      const barHeight = 4;
      const barX = this.x - barWidth/2;
      const barY = this.y - this.r - 8;
      
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      ctx.fillStyle = this.health > this.maxHealth/2 ? '#7ee787' : '#ff9e44';
      ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(255,69,0,0.9)', 8, Math.PI*2, 60);
      return this.health <= 0;
    }
  }

  // Tank enemy class
  class Tank {
    constructor(spawnX, spawnY) {
      this.x = spawnX;
      this.y = spawnY;
      this.r = 20;
      this.health = 6 + bossesKilled;
      this.maxHealth = 6 + bossesKilled;
      this.speed = 15;
      this.maxSpeed = 30;
      this.color = '#8b4513';
      this.throwTimer = 0;
      this.throwCooldown = 4;
      this.age = 0;
      this.spikes = 8;
      this.spikeLength = 8;
      this.frozen = false;
      this.originalSpeed = 15;
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.age += dt;
      this.throwTimer += dt;
      
      this.speed = Math.min(this.maxSpeed, 15 + this.age * 0.5);
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt;
      this.y += toPlayer.y * this.speed * dt;
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
      
      if (this.throwTimer >= this.throwCooldown) {
        this.throwTimer = 0;
        this.throwSlim();
      }
      
      return this.health > 0;
    }
    
    throwSlim() {
      const angle = Math.atan2(player.y - this.y, player.x - this.x);
      const inaccuracy = (Math.random() - 0.5) * 0.5;
      const throwAngle = angle + inaccuracy;
      
      const throwDistance = Math.min(W/6, H/6);
      const targetX = this.x + Math.cos(throwAngle) * throwDistance;
      const targetY = this.y + Math.sin(throwAngle) * throwDistance;
      
      spawnIndicators.push(new SpawnIndicator(targetX, targetY, 'slim'));
      
      setTimeout(() => {
        if (running) {
          echoes.push(new Slim(targetX, targetY));
          playSound('tankThrow');
          spawnParticles(targetX, targetY, 'rgba(255,149,0,0.9)', 10, Math.PI*2, 60);
        }
      }, 1000);
    }
    
    draw(ctx) {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.strokeStyle = '#5a2d0c';
      ctx.lineWidth = 3;
      for (let i = 0; i < this.spikes; i++) {
        const angle = (i / this.spikes) * Math.PI * 2;
        const spikeX = this.x + Math.cos(angle) * (this.r + 2);
        const spikeY = this.y + Math.sin(angle) * (this.r + 2);
        const endX = this.x + Math.cos(angle) * (this.r + this.spikeLength);
        const endY = this.y + Math.sin(angle) * (this.r + this.spikeLength);
        
        ctx.beginPath();
        ctx.moveTo(spikeX, spikeY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }
      
      ctx.strokeStyle = 'rgba(0,0,0,0.7)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.stroke();
      
      const barWidth = this.r * 1.5;
      const barHeight = 4;
      const barX = this.x - barWidth/2;
      const barY = this.y - this.r - 8;
      
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      ctx.fillStyle = this.health > this.maxHealth/2 ? '#7ee787' : '#ff9e44';
      ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(139,69,19,0.9)', 8, Math.PI*2, 60);
      return this.health <= 0;
    }
  }

  // Bow enemy class
  class Bow {
    constructor(spawnX, spawnY) {
      this.x = spawnX;
      this.y = spawnY;
      this.r = 10;
      this.health = 2;
      this.maxHealth = 2;
      this.speed = 10;
      this.color = '#4dabf7';
      this.fireTimer = 0;
      this.fireCooldown = 2;
      this.age = 0;
      this.aimAngle = 0;
      this.frozen = false;
      this.originalSpeed = 10;
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.age += dt;
      this.fireTimer += dt;
      
      this.aimAngle = Math.atan2(player.y - this.y, player.x - this.x);
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt * 0.3;
      this.y += toPlayer.y * this.speed * dt * 0.3;
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
      
      if (this.fireTimer >= this.fireCooldown) {
        this.fireTimer = 0;
        this.fire();
      }
      
      return this.health > 0;
    }
    
    fire() {
      const inaccuracy = (Math.random() - 0.5) * 0.3;
      const angle = this.aimAngle + inaccuracy;
      
      bullets.push({
        x: this.x,
        y: this.y,
        dx: Math.cos(angle),
        dy: Math.sin(angle),
        t: 0,
        life: 2.0,
        speed: 200,
        size: 6,
        color: '#4dabf7',
        enemy: true
      });
      
      playSound('bowFire');
      spawnParticles(this.x, this.y, 'rgba(77,171,247,0.9)', 5, Math.PI/4, 40);
    }
    
    draw(ctx) {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.strokeStyle = '#2d7fcc';
      ctx.lineWidth = 3;
      const bowLength = this.r * 1.5;
      const bowAngle = Math.PI / 6;
      
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(
        this.x + Math.cos(this.aimAngle - bowAngle) * bowLength,
        this.y + Math.sin(this.aimAngle - bowAngle) * bowLength
      );
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(
        this.x + Math.cos(this.aimAngle + bowAngle) * bowLength,
        this.y + Math.sin(this.aimAngle + bowAngle) * bowLength
      );
      ctx.stroke();
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(
        this.x + Math.cos(this.aimAngle - bowAngle) * bowLength,
        this.y + Math.sin(this.aimAngle - bowAngle) * bowLength
      );
      ctx.lineTo(
        this.x + Math.cos(this.aimAngle + bowAngle) * bowLength,
        this.y + Math.sin(this.aimAngle + bowAngle) * bowLength
      );
      ctx.stroke();
      
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r * 0.3, 0, Math.PI*2);
      ctx.fill();
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(77,171,247,0.9)', 5, Math.PI*2, 40);
      return this.health <= 0;
    }
  }

  // Witch enemy class
  class Witch {
    constructor(spawnX, spawnY) {
      this.x = spawnX;
      this.y = spawnY;
      this.r = 15;
      this.health = 2;
      this.maxHealth = 2;
      this.speed = 40;
      this.color = '#a78bfa';
      this.castTimer = 0;
      this.castCooldown = 8;
      this.age = 0;
      this.pulse = 0;
      this.frozen = false;
      this.originalSpeed = 40;
    }

    update(dt) {
      if (this.frozen) return true;
      
      this.age += dt;
      this.castTimer += dt;
      this.pulse += dt * 5;
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt * 0.2;
      this.y += toPlayer.y * this.speed * dt * 0.2;
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
      
      if (this.castTimer >= this.castCooldown) {
        this.castTimer = 0;
        this.castSpell();
      }
      
      return this.health > 0;
    }
    
    castSpell() {
      this.health -= 1;
      spawnParticles(this.x, this.y, 'rgba(167,139,250,0.9)', 15, Math.PI*2, 80);
      playSound('witchCast');
      
      if (this.health > 0) {
        const spellType = Math.floor(Math.random() * 4);
        
        switch(spellType) {
          case 0:
            for (let i = 0; i < 4; i++) {
              const angle = (i / 4) * Math.PI * 2;
              const distance = 50;
              const spawnX = this.x + Math.cos(angle) * distance;
              const spawnY = this.y + Math.sin(angle) * distance;
              spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'slim'));
              
              setTimeout(() => {
                if (running) {
                  echoes.push(new Slim(spawnX, spawnY));
                }
              }, 1000);
            }
            break;
            
          case 1:
            for (let i = 0; i < 2; i++) {
              const angle = (i / 2) * Math.PI * 2;
              const distance = 60;
              const spawnX = this.x + Math.cos(angle) * distance;
              const spawnY = this.y + Math.sin(angle) * distance;
              spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'normal'));
              
              setTimeout(() => {
                if (running) {
                  echoes.push(new Echo(spawnX, spawnY));
                }
              }, 1000);
            }
            break;
            
          case 2:
            for (let i = 0; i < 2; i++) {
              const angle = (i / 2) * Math.PI * 2;
              const distance = 70;
              const spawnX = this.x + Math.cos(angle) * distance;
              const spawnY = this.y + Math.sin(angle) * distance;
              spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'bow'));
              
              setTimeout(() => {
                if (running) {
                  echoes.push(new Bow(spawnX, spawnY));
                }
              }, 1000);
            }
            break;
            
          case 3:
            for (let i = 0; i < 2; i++) {
              const angle = (i / 2) * Math.PI * 2;
              const distance = 70;
              const spawnX = this.x;
              const spawnY = this.y;
              spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'bomber'));
              
              setTimeout(() => {
                if (running) {
                  echoes.push(new Tank(spawnX, spawnY));
                }
              }, 1000);
              break;
          }
        }
      }
    }
    
    draw(ctx) {
      const pulseSize = 1 + Math.sin(this.pulse) * 0.1;
      
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.r*3);
      g.addColorStop(0, 'rgba(167,139,250,0.6)');
      g.addColorStop(1, 'rgba(167,139,250,0.1)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*3, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r * pulseSize, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.moveTo(this.x - this.r*1.2, this.y - this.r*0.5);
      ctx.lineTo(this.x, this.y - this.r*1.8);
      ctx.lineTo(this.x + this.r*1.2, this.y - this.r*0.5);
      ctx.fill();
      
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2 + this.pulse;
        const runeX = this.x + Math.cos(angle) * this.r * 1.5;
        const runeY = this.y + Math.sin(angle) * this.r * 1.5;
        
        ctx.beginPath();
        ctx.arc(runeX, runeY, 3, 0, Math.PI*2);
        ctx.stroke();
      }
      
      const barWidth = this.r * 1.5;
      const barHeight = 4;
      const barX = this.x - barWidth/2;
      const barY = this.y - this.r - 8;
      
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      ctx.fillStyle = this.health > this.maxHealth/2 ? '#7ee787' : '#ff9e44';
      ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(167,139,250,0.9)', 8, Math.PI*2, 60);
      return this.health <= 0;
    }
  }

  // sniper enemy class - IMPROVED LOOKS
  class sniper {
    constructor(spawnX, spawnY) {
      this.x = spawnX;
      this.y = spawnY;
      this.r = 25;
      this.health = 25;
      this.maxHealth = 25;
      this.speed = 20;
      this.color = '#8a2be2';
      this.fireTimer = 0;
      this.fireCooldown = 3;
      this.age = 0;
      this.frozen = false;
      this.originalSpeed = 20;
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.age += dt;
      this.fireTimer += dt;
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt * 0.5;
      this.y += toPlayer.y * this.speed * dt * 0.5;
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
      
      if (this.fireTimer >= this.fireCooldown) {
        this.fireTimer = 0;
        this.fire();
      }
      
      return this.health > 0;
    }
    
    fire() {
      const angle = Math.atan2(player.y - this.y, player.x - this.x);
      
      bullets.push({
        x: this.x,
        y: this.y,
        dx: Math.cos(angle),
        dy: Math.sin(angle),
        t: 0,
        life: 3.0,
        speed: 600,
        size: 20,
        color: '#8a2be2',
        enemy: true,
        sniper: true
      });
      
      playSound('tankThrow');
      spawnParticles(this.x, this.y, 'rgba(138,43,226,0.9)', 20, Math.PI*2, 100);
    }
    
    draw(ctx) {
      // Improved sniper appearance
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      // Crown details
      ctx.fillStyle = '#ffd700';
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const spikeX = this.x + Math.cos(angle) * (this.r - 5);
        const spikeY = this.y + Math.sin(angle) * (this.r - 5);
        ctx.beginPath();
        ctx.moveTo(spikeX, spikeY);
        ctx.lineTo(
          this.x + Math.cos(angle) * (this.r + 8),
          this.y + Math.sin(angle) * (this.r + 8)
        );
        ctx.lineTo(
          this.x + Math.cos(angle + 0.3) * (this.r - 2),
          this.y + Math.sin(angle + 0.3) * (this.r - 2)
        );
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.strokeStyle = '#4b0082';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.stroke();
      
      // Cannon - improved appearance
      const cannonAngle = Math.atan2(player.y - this.y, player.x - this.x);
      const cannonLength = this.r * 1.5;
      const cannonEndX = this.x + Math.cos(cannonAngle) * cannonLength;
      const cannonEndY = this.y + Math.sin(cannonAngle) * cannonLength;
      
      ctx.strokeStyle = '#4b0082';
      ctx.lineWidth = 12;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(cannonEndX, cannonEndY);
      ctx.stroke();
      
      // Cannon tip
      ctx.fillStyle = '#4b0082';
      ctx.beginPath();
      ctx.arc(cannonEndX, cannonEndY, 8, 0, Math.PI*2);
      ctx.fill();
      
      const barWidth = this.r * 1.5;
      const barHeight = 4;
      const barX = this.x - barWidth/2;
      const barY = this.y - this.r - 8;
      
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      ctx.fillStyle = this.health > this.maxHealth/2 ? '#7ee787' : '#ff9e44';
      ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(138,43,226,0.9)', 10, Math.PI*2, 80);
      return this.health <= 0;
    }
  }

  // Bomber enemy class - IMPROVED EXPLOSION PARTICLES
  class Bomber {
    constructor(spawnX, spawnY) {
      this.x = spawnX;
      this.y = spawnY;
      this.r = 12;
      this.health = 2;
      this.maxHealth = 2;
      this.speed = 111;
      this.color = '#006400';
      this.age = 0;
      this.frozen = false;
      this.originalSpeed = 111;
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.age += dt;
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt;
      this.y += toPlayer.y * this.speed * dt;
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
      
      return this.health > 0;
    }
    
    draw(ctx) {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.arc(this.x - this.r*0.3, this.y, this.r*0.2, 0, Math.PI*2);
      ctx.arc(this.x + this.r*0.3, this.y, this.r*0.2, 0, Math.PI*2);
      ctx.fill();
      
      // Fuse with animation
      ctx.strokeStyle = '#ff9500';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y - this.r);
      ctx.lineTo(this.x, this.y - this.r - 5 - Math.sin(this.age * 10) * 2);
      ctx.stroke();
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(0,100,0,0.9)', 5, Math.PI*2, 40);
      
      if (this.health <= 0) {
        // Spawn 3 slims on death with improved explosion particles
        for (let i = 0; i < 3; i++) {
          const angle = (i / 3) * Math.PI * 2;
          const distance = 55;
          const spawnX = this.x + Math.cos(angle) * distance;
          const spawnY = this.y + Math.sin(angle) * distance;
          echoes.push(new Slim(spawnX, spawnY));
        }
        
        // Improved explosion particles - more and varied
        spawnParticles(this.x, this.y, 'rgba(255,100,0,0.9)', 40, Math.PI*2, 150); // Orange
        spawnParticles(this.x, this.y, 'rgba(255,200,0,0.7)', 35, Math.PI*2, 120); // Yellow
        spawnParticles(this.x, this.y, 'rgba(100,255,0,0.5)', 30, Math.PI*2, 100); // Green
        spawnParticles(this.x, this.y, 'rgba(255,0,0,0.8)', 25, Math.PI*2, 80); // Red
        return true;
      }
      
      return false;
    }
  }

  // Ghost class - ALWAYS seeks nearest enemy
  class Ghost {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.r = 12;
      this.life = 5.0;
      this.maxLife = 5.0;
      this.speed = 200;
      this.damage = 1;
      this.color = '#a78bfa';
      this.target = null;
      this.damageTimer = 0;
      this.wanderTimer = 0;
      this.wanderDirection = {x: Math.random() - 0.5, y: Math.random() - 0.5};
      // Normalize wander direction
      const mag = Math.sqrt(this.wanderDirection.x * this.wanderDirection.x + this.wanderDirection.y * this.wanderDirection.y);
      if (mag > 0) {
        this.wanderDirection.x /= mag;
        this.wanderDirection.y /= mag;
      }
    }
    
    update(dt) {
      this.life -= dt;
      this.damageTimer += dt;
      this.wanderTimer += dt;
      
      // Find nearest enemy
      let nearestEnemy = null;
      let nearestDist = Infinity;
      for (const e of echoes) {
        // Skip if it's a boss (ghosts should focus on regular enemies)
        if (e instanceof EasyBoss || e instanceof MediumBoss || e instanceof HardBoss || e instanceof FinalBoss || e instanceof MegaCreeperBoss) {
          continue;
        }
        
        const d = dist({x: this.x, y: this.y}, e);
        if (d < nearestDist) {
          nearestEnemy = e;
          nearestDist = d;
        }
      }
      
      // If no regular enemies found, target bosses
      if (!nearestEnemy) {
        for (const e of echoes) {
          const d = dist({x: this.x, y: this.y}, e);
          if (d < nearestDist) {
            nearestEnemy = e;
            nearestDist = d;
          }
        }
      }
      
      this.target = nearestEnemy;
      
      if (this.target) {
        // Always move toward target
        const aim = vecTo(this.x, this.y, this.target.x, this.target.y);
        this.x += aim.x * this.speed * dt;
        this.y += aim.y * this.speed * dt;
        
        // Deal damage when close to any enemy (not just target)
        if (this.damageTimer >= 1.0) {
          this.damageTimer = 0;
          for (const e of echoes) {
            if (dist({x: this.x, y: this.y}, e) < this.r + e.r) {
              e.takeDamage(this.damage);
              spawnParticles(e.x, e.y, 'rgba(167,139,250,0.7)', 3, Math.PI, 20);
            }
          }
        }
      } else {
        // No enemies found, wander around
        if (this.wanderTimer > 1) {
          this.wanderTimer = 0;
          this.wanderDirection = {x: Math.random() - 0.5, y: Math.random() - 0.5};
          const mag = Math.sqrt(this.wanderDirection.x * this.wanderDirection.x + this.wanderDirection.y * this.wanderDirection.y);
          if (mag > 0) {
            this.wanderDirection.x /= mag;
            this.wanderDirection.y /= mag;
          }
        }
        
        this.x += this.wanderDirection.x * this.speed * dt * 0.5;
        this.y += this.wanderDirection.y * this.speed * dt * 0.5;
      }
      
      return this.life > 0;
    }
    
    draw(ctx) {
      const alpha = this.life / this.maxLife;
      const scale = 0.8 + (this.life / this.maxLife) * 0.4;
      
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.r*4 * scale);
      g.addColorStop(0, `rgba(167,139,250,${alpha * 0.8})`);
      g.addColorStop(1, `rgba(167,139,250,${alpha * 0.1})`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r*4 * scale, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = `rgba(167,139,250,${alpha * 0.9})`;
      ctx.arc(this.x, this.y, this.r * scale, 0, Math.PI*2);
      ctx.fill();
      
      // Ghost eyes (always face the direction of movement)
      let eyeDirectionX = 0;
      let eyeDirectionY = 0;
      
      if (this.target) {
        eyeDirectionX = this.target.x - this.x;
        eyeDirectionY = this.target.y - this.y;
      } else {
        eyeDirectionX = this.wanderDirection.x;
        eyeDirectionY = this.wanderDirection.y;
      }
      
      // Normalize eye direction
      const eyeMag = Math.sqrt(eyeDirectionX * eyeDirectionX + eyeDirectionY * eyeDirectionY);
      if (eyeMag > 0) {
        eyeDirectionX /= eyeMag;
        eyeDirectionY /= eyeMag;
      }
      
      // Position eyes based on movement direction
      const eyeOffsetX = eyeDirectionX * this.r * 0.3;
      const eyeOffsetY = eyeDirectionY * this.r * 0.3;
      const perpendicularX = -eyeDirectionY * this.r * 0.2;
      const perpendicularY = eyeDirectionX * this.r * 0.2;
      
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,${alpha * 0.8})`;
      // Left eye
      ctx.arc(this.x - perpendicularX + eyeOffsetX, this.y - perpendicularY + eyeOffsetY, this.r*0.15 * scale, 0, Math.PI*2);
      // Right eye
      ctx.arc(this.x + perpendicularX + eyeOffsetX, this.y + perpendicularY + eyeOffsetY, this.r*0.15 * scale, 0, Math.PI*2);
      ctx.fill();
      
      const barWidth = this.r * 2 * scale;
      const barHeight = 3;
      const barX = this.x - barWidth/2;
      const barY = this.y - this.r * 1.5 * scale;
      
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      ctx.fillStyle = '#a78bfa';
      ctx.fillRect(barX, barY, barWidth * (this.life / this.maxLife), barHeight);
    }
  }

  // Worker class
  class Worker {
    constructor() {
      this.angle = Math.random() * Math.PI * 2;
      this.distance = 60;
      this.speed = 4;
      this.size = 6; 
      this.fireTimer = 0;
      this.fireRate = 0.8;
      this.color = '#4dabf7';
      this.damage = 1; 
      this.x = 0;
      this.y = 0;
      this.orbitSpeed = 2;
    }
    
    update(dt, playerX, playerY) {
      this.angle += this.orbitSpeed * dt;
      this.x = playerX + Math.cos(this.angle) * this.distance;
      this.y = playerY + Math.sin(this.angle) * this.distance;
      
      this.fireTimer += dt;
      if (this.fireTimer >= this.fireRate) {
        this.fireTimer = 0;
        
        let nearest = null;
        let nearestDist = Infinity;
        for (const e of echoes) {
          const d = dist({x: this.x, y: this.y}, e);
          if (d < nearestDist) {
            nearest = e;
            nearestDist = d;
          }
        }
        
        if (nearest && nearestDist < 400) {
          const aim = vecTo(this.x, this.y, nearest.x, nearest.y);
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            dx: aim.x, 
            dy: aim.y, 
            t:0, 
            life: 0.7,
            speed: 700, 
            size: 5, 
            color: '#4dabf7',
            worker: true,
            damage: this.damage
          });
          
          sfx(800, 0.03, 0.008, 'sine');
          spawnParticles(this.x, this.y, 'rgba(77,171,247,0.9)', 4, Math.PI/4, 30);
        }
      }
    }
    
    draw(ctx) {
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.size*2);
      g.addColorStop(0, this.color + 'DD');
      g.addColorStop(1, this.color + '11');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.size*2, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.arc(this.x, this.y, this.size*0.5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Worker Collector class
  class WorkerCollector {
    constructor() {
      this.x = Math.random() * W;
      this.y = Math.random() * H;
      this.r = 8;
      this.speed = 100;
      this.color = '#63e6be';
      this.target = null;
      this.xpMultiplier = 1;
      this.fireTimer = 0;
      this.fireCooldown = 0.3;
      this.wanderTimer = 0;
      this.wanderDirection = {x: Math.random() - 0.5, y: Math.random() - 0.5};
      const mag = Math.sqrt(this.wanderDirection.x * this.wanderDirection.x + this.wanderDirection.y * this.wanderDirection.y);
      if (mag > 0) {
        this.wanderDirection.x /= mag;
        this.wanderDirection.y /= mag;
      }
      
      // Fire trail
      this.fireTrailTimer = 0;
      this.fireTrailCooldown = 0.2;
    }
    
    update(dt) {
      this.fireTimer += dt;
      this.wanderTimer += dt;
      this.fireTrailTimer += dt;
      
      // Find nearest XP orb or any upgrade
      let nearestXP = null;
      let nearestDist = Infinity;
      for (const u of upgrades) {
        const d = dist({x: this.x, y: this.y}, u);
        if (d < nearestDist) {
          nearestXP = u;
          nearestDist = d;
        }
      }
      
        if (nearestXP) {
            const toXP = vecTo(this.x, this.y, nearestXP.x, nearestXP.y);
            this.x += toXP.x * this.speed * dt;
            this.y += toXP.y * this.speed * dt;
            
            if (dist({x: this.x, y: this.y}, nearestXP) < this.r + nearestXP.r) {
                let baseXP = 30;
                let xpMultiplier = 1;
                
                if (player.stats.xpBoost.level >= 1) {
                    baseXP = 50; // Level 1: +20 XP (from 30 to 50)
                }
                
                if (player.stats.xpBoost.level >= 2) {
                    xpMultiplier = 1.5; // Level 2: +50% on 50 = 75 XP
                }
                
                if (player.stats.xpBoost.level >= 5) {
                    xpMultiplier *= 1.5; // Level 5: Additional 50% bonus
                }
                
                playerXP += baseXP * xpMultiplier * this.xpMultiplier;
                upgrades.splice(upgrades.indexOf(nearestXP), 1);
                spawnParticles(nearestXP.x, nearestXP.y, nearestXP.colors[nearestXP.type] + 'DD', 20, Math.PI*2, 80);
                sfx(1000, 0.08, 0.025, 'sine');
            }
      } else {
        if (this.wanderTimer > 2) {
          this.wanderTimer = 0;
          this.wanderDirection = {x: Math.random() - 0.5, y: Math.random() - 0.5};
          const mag = Math.sqrt(this.wanderDirection.x * this.wanderDirection.x + this.wanderDirection.y * this.wanderDirection.y);
          if (mag > 0) {
            this.wanderDirection.x /= mag;
            this.wanderDirection.y /= mag;
          }
        }
        
        this.x += this.wanderDirection.x * this.speed * dt * 0.5;
        this.y += this.wanderDirection.y * this.speed * dt * 0.5;
      }
      
      // Fire trail for level 3
      if (player.stats.workerCollector.level >= 3 && this.fireTrailTimer >= this.fireTrailCooldown) {
        this.fireTrailTimer = 0;
        fires.push(new Fire(this.x, this.y, 30, 3, 3));
      }
      
      // Auto-aim weapon for level 4
      if (player.stats.workerCollector.level >= 4 && this.fireTimer >= this.fireCooldown) {
        this.fireTimer = 0;
        
        let nearest = null;
        let nearestDist = Infinity;
        for (const e of echoes) {
          const d = dist({x: this.x, y: this.y}, e);
          if (d < nearestDist) {
            nearest = e;
            nearestDist = d;
          }
        }
        
        if (nearest && nearestDist < 400) {
          const aim = vecTo(this.x, this.y, nearest.x, nearest.y);
          bullets.push({ 
            x: this.x, 
            y: this.y, 
            dx: aim.x, 
            dy: aim.y, 
            t:0, 
            life: 0.6,
            speed: 500, 
            size: 2, 
            color: '#63e6be',
            worker: true,
            damage: 1
          });
          
          sfx(800, 0.03, 0.008, 'sine');
          spawnParticles(this.x, this.y, 'rgba(99,230,190,0.9)', 4, Math.PI/4, 30);
        }
      }
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
    }
    
    draw(ctx) {
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.r*3);
      g.addColorStop(0, this.color + 'DD');
      g.addColorStop(1, this.color + '11');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r*3, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.arc(this.x, this.y, this.r*0.5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Easy Boss class
  class EasyBoss {
    constructor() {
      let angle = Math.random() * Math.PI * 2;
      let distance = 300;
      this.x = player.x + Math.cos(angle) * distance;
      this.y = player.y + Math.sin(angle) * distance;
      
      this.x = clamp(this.x, 100, W-100);
      this.y = clamp(this.y, 100, H-100);
      
      this.r = 35;
      this.health = 40;
      this.maxHealth = 40;
      this.speed = 50;
      this.color = '#ff4757';
      this.attackTimer = 0;
      this.attackRate = 2;
      this.pulse = 0;
      this.bulletAngle = 0;
      this.frozen = false;
      this.originalSpeed = 50;
      
      createBossSpawnEffect(this.x, this.y);
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.pulse += dt * 3;
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt;
      this.y += toPlayer.y * this.speed * dt;
      
      this.attackTimer += dt;
      if (this.attackTimer >= this.attackRate) {
        this.attackTimer = 0;
        
        const bulletCount = 5;
        for (let i = 0; i < bulletCount; i++) {
          const angle = (i / bulletCount) * Math.PI * 2;
          bullets.push({
            x: this.x,
            y: this.y,
            dx: Math.cos(angle),
            dy: Math.sin(angle),
            t: 0,
            life: 4.0,
            speed: 110,
            size: 11,
            color: '#ff4757',
            enemy: true
          });
        }
        
        sfx(200, 0.1, 0.04, 'sawtooth');
        spawnParticles(this.x, this.y, 'rgba(255,71,87,0.9)', 15, Math.PI*2, 80);
      }
          
    // Remove dead bosses from echoes array
    if (this.health <= 0) {
      const index = echoes.indexOf(this);
      if (index > -1) {
        echoes.splice(index, 1);
      }
      return false;
    }
    return true;    
  }
    
    draw(ctx) {
      const pulseSize = this.r * (1 + Math.sin(this.pulse) * 0.1);
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, pulseSize*2);
      g.addColorStop(0, this.color + 'DD');
      g.addColorStop(1, this.color + '11');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, pulseSize*2, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.arc(this.x, this.y, this.r*0.7, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = '#ff6b6b';
      ctx.arc(this.x - this.r*0.3, this.y - this.r*0.2, this.r*0.15, 0, Math.PI*2);
      ctx.arc(this.x + this.r*0.3, this.y - this.r*0.2, this.r*0.15, 0, Math.PI*2);
      ctx.fill();
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(255,255,255,0.9)', 8, Math.PI*2, 60);
      return this.health <= 0;
    }
  }

  // Medium Boss class
  class MediumBoss {
    constructor() {
      let angle = Math.random() * Math.PI * 2;
      let distance = 350;
      this.x = player.x + Math.cos(angle) * distance;
      this.y = player.y + Math.sin(angle) * distance;
      
      this.x = clamp(this.x, 120, W-120);
      this.y = clamp(this.y, 120, H-120);
      
      this.r = 45;
      this.health = 100;
      this.maxHealth = 100;
      this.speed = 80;
      this.color = '#ff0099';
      this.attackTimer = 0;
      this.attackRate = 3.0;
      this.pulse = 0;
      this.bulletAngle = 0;
      this.phase = 1;
      this.frozen = false;
      this.originalSpeed = 80;

      createBossSpawnEffect(this.x, this.y);
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.pulse += dt * 3;
      
      if (this.health < this.maxHealth * 0.5 && this.phase === 1) {
        this.phase = 2;
        this.speed = 130;
        this.attackRate = 2;
      }
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt;
      this.y += toPlayer.y * this.speed * dt;
      
      this.attackTimer += dt;
      if (this.attackTimer >= this.attackRate) {
        this.attackTimer = 0;
        
        const bulletCount = this.phase === 1 ? 5 : 10;
        
        for (let i = 0; i < bulletCount; i++) {
          const angle = this.bulletAngle + (i / bulletCount) * Math.PI * 2;
          bullets.push({
            x: this.x,
            y: this.y,
            dx: Math.cos(angle),
            dy: Math.sin(angle),
            t: 0,
            life: 2,
            speed: 200,
            size: 8,
            color: '#ff6b6b',
            enemy: true
          });
        }
        
        this.bulletAngle += 0.4;
        
        sfx(180, 0.15, 0.05, 'sawtooth');
        spawnParticles(this.x, this.y, 'rgba(255,107,107,0.9)', 20, Math.PI*2, 100);
      }
      
        
      // Remove dead bosses from echoes array
      if (this.health <= 0) {
        const index = echoes.indexOf(this);
        if (index > -1) {
          echoes.splice(index, 1);
        }
        return false;
      }
      return true;    
  }
    
    draw(ctx) {
      const phaseColors = ['#ff6b6b', '#ff4757'];
      const pulseSize = this.r * (1 + Math.sin(this.pulse) * 0.1);
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, pulseSize*2);
      g.addColorStop(0, phaseColors[this.phase-1] + 'DD');
      g.addColorStop(1, phaseColors[this.phase-1] + '11');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, pulseSize*2, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = phaseColors[this.phase-1];
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.arc(this.x, this.y, this.r*0.8, 0, Math.PI*2);
      ctx.fill();
      
      const eyeCount = this.phase + 1;
      for (let i = 0; i < eyeCount; i++) {
        const angle = (i / eyeCount) * Math.PI * 2;
        const eyeX = this.x + Math.cos(angle) * this.r * 0.5;
        const eyeY = this.y + Math.sin(angle) * this.r * 0.5;
        
        ctx.beginPath();
        ctx.fillStyle = '#ff8e8e';
        ctx.arc(eyeX, eyeY, this.r*0.12, 0, Math.PI*2);
        ctx.fill();
      }
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(255,255,255,0.9)', 10, Math.PI*2, 70);
      return this.health <= 0;
    }
  }

  // Hard Boss class
  class HardBoss {
    constructor() {
      let angle = Math.random() * Math.PI * 2;
      let distance = 400;
      this.x = player.x + Math.cos(angle) * distance;
      this.y = player.y + Math.sin(angle) * distance;
      
      this.x = clamp(this.x, 150, W-150);
      this.y = clamp(this.y, 150, H-150);
      
      this.r = 60;
      this.health = 250;
      this.maxHealth = 250;
      this.speed = 40;
      this.color = '#8b0000';
      this.attackTimer = 0;
      this.attackRate = 2;
      this.pulse = 0;
      this.phase = 1;
      this.bulletAngle = 0;
      this.specialAttackTimer = 0;
      this.specialAttackCooldown = 8;
      this.frozen = false;
      this.originalSpeed = 40;
      
      createBossSpawnEffect(this.x, this.y);
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.pulse += dt * 4;
      this.specialAttackTimer += dt;
      
      // FIX: Add shrink cap to prevent bosses from becoming invisible
      this.r = Math.max(30, 60 * (this.health / this.maxHealth));
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt;
      this.y += toPlayer.y * this.speed * dt;
      
      if (this.health < this.maxHealth * 0.5 && this.phase === 1) {
        this.phase = 2;
        this.speed = 50;
        this.attackRate = 1.5;
      }
      if (this.health < this.maxHealth * 0.25 && this.phase === 2) {
        this.phase = 3;
        this.speed = 60;
        this.attackRate = 1;
      }
      
      this.attackTimer += dt;
      if (this.attackTimer >= this.attackRate) {
        this.attackTimer = 0;
        
        const bulletCount = this.phase === 1 ? 6 : this.phase === 2 ? 12 : 24;
        
        for (let i = 0; i < bulletCount; i++) {
          const angle = this.bulletAngle + (i / bulletCount) * Math.PI * 2;
          bullets.push({
            x: this.x,
            y: this.y,
            dx: Math.cos(angle),
            dy: Math.sin(angle),
            t: 0,
            life: 4.0,
            speed: 50 + this.phase * 35,
            size: 24 - this.phase * 4,
            color: '#8b0000',
            enemy: true
          });
        }
        
        this.bulletAngle += 0.3;
        
        sfx(120, 0.2, 0.06, 'sawtooth');
        spawnParticles(this.x, this.y, 'rgba(139,0,0,0.9)', 30, Math.PI*2, 120);
      }
      
      if (this.specialAttackTimer >= this.specialAttackCooldown) {
        this.specialAttackTimer = 0;
        this.specialAttack();
      }
      
      // Remove dead bosses from echoes array
      if (this.health <= 0) {
        const index = echoes.indexOf(this);
        if (index > -1) {
          echoes.splice(index, 1);
        }
        return false;
      }
      return true;    
    }
    
    specialAttack() {
      const bulletCount = 24;
      for (let i = 0; i < bulletCount; i++) {
        const angle = (i / bulletCount) * Math.PI * 2;
        bullets.push({
          x: this.x,
          y: this.y,
          dx: Math.cos(angle),
          dy: Math.sin(angle),
          t: 0,
          life: 5.0,
          speed: 150,
          size: 12,
          color: '#dc143c',
          enemy: true
        });
      }
      
      shake = 25;
      sfx(100, 0.3, 0.08, 'sawtooth');
      
      spawnParticles(this.x, this.y, 'rgba(220,20,60,0.9)', 50, Math.PI*2, 200);
      spawnParticles(this.x, this.y, 'rgba(255,0,0,0.7)', 40, Math.PI*2, 180);
      spawnParticles(this.x, this.y, 'rgba(255,100,0,0.5)', 30, Math.PI*2, 160);
    }
    
    draw(ctx) {
      const phaseColors = ['#8b0000', '#b22222', '#dc143c'];
      const pulseSize = this.r * (1 + Math.sin(this.pulse) * 0.15);
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, pulseSize*2);
      g.addColorStop(0, phaseColors[this.phase-1] + 'DD');
      g.addColorStop(1, phaseColors[this.phase-1] + '11');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, pulseSize*2, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = phaseColors[this.phase-1];
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.arc(this.x, this.y, this.r*0.8, 0, Math.PI*2);
      ctx.fill();
      
      const eyeCount = this.phase;
      for (let i = 0; i < eyeCount; i++) {
        const angle = (i / eyeCount) * Math.PI * 2;
        const eyeX = this.x + Math.cos(angle) * this.r * 0.5;
        const eyeY = this.y + Math.sin(angle) * this.r * 0.5;
        
        ctx.beginPath();
        ctx.fillStyle = '#ff6b6b';
        ctx.arc(eyeX, eyeY, this.r*0.15, 0, Math.PI*2);
        ctx.fill();
      }
      
      if (this.specialAttackTimer > this.specialAttackCooldown - 2) {
        const warningPulse = Math.sin(this.specialAttackTimer * 10) * 0.5 + 0.5;
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,0,${warningPulse})`;
        ctx.lineWidth = 3;
        ctx.arc(this.x, this.y, this.r * 1.5, 0, Math.PI*2);
        ctx.stroke();
      }
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(255,255,255,0.9)', 15, Math.PI*2, 100);
      return this.health <= 0;
    }
  }

  // Final Boss class - IMPROVED
  class FinalBoss {
    constructor() {
      let angle = Math.random() * Math.PI * 2;
      let distance = 500;
      this.x = player.x + Math.cos(angle) * distance;
      this.y = player.y + Math.sin(angle) * distance;
      
      this.x = clamp(this.x, 200, W-200);
      this.y = clamp(this.y, 200, H-200);
      
      this.r = 80;
      this.health = 1000;
      this.maxHealth = 1000;
      this.speed = 50;
      this.color = '#4b0082';
      this.attackTimer = 0;
      this.attackRate = 1;
      this.pulse = 0;
      this.phase = 1;
      this.bulletAngle = 0;
      this.specialAttackTimer = 0;
      this.specialAttackCooldown = 10;
      this.cannonTimer = 0;
      this.cannonCooldown = 5;
      this.heatSeekingTimer = 0;
      this.heatSeekingCooldown = 8;
      this.frozen = false;
      this.originalSpeed = 60;
      this.reflectionWalls = [];
      this.coverBlocks = [];
      
      // Create cover blocks for the player to hide behind - 100% larger
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        const distance = 200;
        const blockX = W/2 + Math.cos(angle) * distance;
        const blockY = H/2 + Math.sin(angle) * distance;
        this.coverBlocks.push({
          x: blockX,
          y: blockY,
          width: 60, 
          height: 60
        });
      }
      
      createBossSpawnEffect(this.x, this.y);
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.pulse += dt * 5;
      this.specialAttackTimer += dt;
      this.cannonTimer += dt;
      this.heatSeekingTimer += dt;
      
      // FIX: Add shrink cap to prevent bosses from becoming invisible
      this.r = Math.max(40, 80 * (this.health / this.maxHealth));
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt;
      this.y += toPlayer.y * this.speed * dt;
      
      if (this.health < this.maxHealth * 0.6 && this.phase === 1) {
        this.phase = 2;
        this.speed = 40;
        this.attackRate = 2;
      }
      if (this.health < this.maxHealth * 0.3 && this.phase === 2) {
        this.phase = 3;
        this.speed = 30;
        this.attackRate = 2;
      }
      if (this.health < this.maxHealth * 0.1 && this.phase === 3) {
        this.phase = 4;
        this.speed = 20;
        this.attackRate = 1.2;
      }
      
      this.attackTimer += dt;
      if (this.attackTimer >= this.attackRate) {
        this.attackTimer = 0;
        
        const bulletCount = this.phase === 1 ? 12 : 
                          this.phase === 2 ? 20 : 
                          this.phase === 3 ? 30 : 40;
        
        for (let i = 0; i < bulletCount; i++) {
          const angle = this.bulletAngle + (i / bulletCount) * Math.PI * 2;
          bullets.push({
            x: this.x,
            y: this.y,
            dx: Math.cos(angle),
            dy: Math.sin(angle),
            t: 0,
            life: 5.0 - this.phase,
            speed: 150 + this.phase * 50,
            size: 21 - this.phase * 4,
            color: '#4b0082',
            enemy: true
          });
        }
        
        this.bulletAngle += 0.2;
        
        sfx(100, 0.25, 0.07, 'sawtooth');
        spawnParticles(this.x, this.y, 'rgba(75,0,130,0.9)', 40, Math.PI*2, 150);
      }
      
      if (this.specialAttackTimer >= this.specialAttackCooldown) {
        this.specialAttackTimer = 0;
        this.specialAttack();
      }
      
      if (this.cannonTimer >= this.cannonCooldown) {
        this.cannonTimer = 0;
        this.fireCannon();
      }
      
      if (this.heatSeekingTimer >= this.heatSeekingCooldown) {
        this.heatSeekingTimer = 0;
        this.fireHeatSeekingMissiles();
      }
      
      // Update reflection walls
      for (let i = this.reflectionWalls.length - 1; i >= 0; i--) {
        const wall = this.reflectionWalls[i];
        wall.timer -= dt;
        if (wall.timer <= 0) {
          this.reflectionWalls.splice(i, 1);
        }
      }
      
            // Update cover blocks - break ENEMY bullets (player bullets can pass through)
      for (const block of this.coverBlocks) {
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          if (b.x > block.x - block.width/2 && b.x < block.x + block.width/2 &&
              b.y > block.y - block.height/2 && b.y < block.y + block.height/2) {
            // Only block enemy bullets, let player bullets pass through
            if (b.enemy) {
              bullets.splice(i, 1);
              spawnParticles(b.x, b.y, 'rgba(100,100,100,0.7)', 5, Math.PI*2, 40);
            }
          }
        }
      }
            
      // Remove dead bosses from echoes array
      if (this.health <= 0) {
        const index = echoes.indexOf(this);
        if (index > -1) {
          echoes.splice(index, 1);
        }
        return false;
      }
      return true;    }
    
    specialAttack() {
      // Dark red fire wave that pushes player away
      const waveCount = 3;
      for (let i = 0; i < waveCount; i++) {
        const delay = i * 0.5;
        setTimeout(() => {
          if (running) {
            const wave = new FireWave(this.x, this.y);
            fires.push(wave);
            
            // Push player away
            const toPlayer = vecTo(this.x, this.y, player.x, player.y);
            const pushForce = 300;
            player.vx += toPlayer.x * pushForce;
            player.vy += toPlayer.y * pushForce;
          }
        }, delay * 1000);
      }
      
      // Create reflection wall
      this.reflectionWalls.push({
        x: this.x,
        y: this.y,
        radius: 150,
        timer: 5.0
      });
      
      shake = 30;
      sfx(80, 0.4, 0.1, 'sawtooth');
      
      spawnParticles(this.x, this.y, 'rgba(138,43,226,0.9)', 60, Math.PI*2, 250);
      spawnParticles(this.x, this.y, 'rgba(75,0,130,0.7)', 50, Math.PI*2, 220);
      spawnParticles(this.x, this.y, 'rgba(148,0,211,0.5)', 40, Math.PI*2, 190);
    }
    
    fireCannon() {
      const angle = Math.atan2(player.y - this.y, player.x - this.x);
      
      bullets.push({
        x: this.x,
        y: this.y,
        dx: Math.cos(angle),
        dy: Math.sin(angle),
        t: 0,
        life: 6.0,
        speed: 120,
        size: 40,
        color: '#ff0000',
        enemy: true,
        finalBossCannon: true
      });
      
      playSound('tankThrow');
      spawnParticles(this.x, this.y, 'rgba(255,0,0,0.9)', 30, Math.PI*2, 150);
    }
    
    fireHeatSeekingMissiles() {
      const missileCount = 3;
      for (let i = 0; i < missileCount; i++) {
        const angle = (i / missileCount) * Math.PI * 2;
        const distance = 50;
        const spawnX = this.x + Math.cos(angle) * distance;
        const spawnY = this.y + Math.sin(angle) * distance;
        
        const heatSeekingRocket = new HeatSeekingRocket(spawnX, spawnY);
        rockets.push(heatSeekingRocket);
      }
      
      playSound('rocket');
    }
    
    draw(ctx) {
      const phaseColors = ['#4b0082', '#6a0dad', '#8a2be2', '#9370db'];
      const pulseSize = this.r * (1 + Math.sin(this.pulse) * 0.2);
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, pulseSize*2);
      g.addColorStop(0, phaseColors[this.phase-1] + 'DD');
      g.addColorStop(1, phaseColors[this.phase-1] + '11');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, pulseSize*2, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = phaseColors[this.phase-1];
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.arc(this.x, this.y, this.r*0.8, 0, Math.PI*2);
      ctx.fill();
      
      // Large cannon
      const cannonAngle = Math.atan2(player.y - this.y, player.x - this.x);
      const cannonLength = this.r * 2;
      const cannonEndX = this.x + Math.cos(cannonAngle) * cannonLength;
      const cannonEndY = this.y + Math.sin(cannonAngle) * cannonLength;
      
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 12;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(cannonEndX, cannonEndY);
      ctx.stroke();
      
      // Cannon tip with glow
      const cannonTipGradient = ctx.createRadialGradient(cannonEndX, cannonEndY, 1, cannonEndX, cannonEndY, 15);
      cannonTipGradient.addColorStop(0, '#dd00ff');
      cannonTipGradient.addColorStop(1, '#ff0088');
      ctx.fillStyle = cannonTipGradient;
      ctx.beginPath();
      ctx.arc(cannonEndX, cannonEndY, 12, 0, Math.PI*2);
      ctx.fill();
      
      const eyeCount = this.phase + 2;
      for (let i = 0; i < eyeCount; i++) {
        const angle = (i / eyeCount) * Math.PI * 2;
        const eyeX = this.x + Math.cos(angle) * this.r * 0.6;
        const eyeY = this.y + Math.sin(angle) * this.r * 0.6;
        
        ctx.beginPath();
        ctx.fillStyle = '#ff6b6b';
        ctx.arc(eyeX, eyeY, this.r*0.2, 0, Math.PI*2);
        ctx.fill();
        
        // Glowing eyes
        const eyeGlow = ctx.createRadialGradient(eyeX, eyeY, 1, eyeX, eyeY, this.r*0.4);
        eyeGlow.addColorStop(0, 'rgba(255,107,107,0.8)');
        eyeGlow.addColorStop(1, 'rgba(255,107,107,0.1)');
        ctx.fillStyle = eyeGlow;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, this.r*0.4, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Draw reflection walls
      for (const wall of this.reflectionWalls) {
        const alpha = wall.timer / 5.0;
        ctx.strokeStyle = `rgba(255,0,0,${alpha * 0.7})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(wall.x, wall.y, wall.radius, 0, Math.PI*2);
        ctx.stroke();
        
        ctx.fillStyle = `rgba(255,0,0,${alpha * 0.2})`;
        ctx.beginPath();
        ctx.arc(wall.x, wall.y, wall.radius, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Draw cover blocks
      for (const block of this.coverBlocks) {
        ctx.fillStyle = 'rgba(100,100,100,0.8)';
        ctx.fillRect(block.x - block.width/2, block.y - block.height/2, block.width, block.height);
        
        ctx.strokeStyle = 'rgba(200,200,200,0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(block.x - block.width/2, block.y - block.height/2, block.width, block.height);
      }
      
      if (this.specialAttackTimer > this.specialAttackCooldown - 3) {
        const warningPulse = Math.sin(this.specialAttackTimer * 10) * 0.5 + 0.5;
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,0,${warningPulse})`;
        ctx.lineWidth = 4;
        ctx.arc(this.x, this.y, this.r * 2, 0, Math.PI*2);
        ctx.stroke();
      }
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(255,255,255,0.9)', 20, Math.PI*2, 120);
      return this.health <= 0;
    }
  }

  // NEW: Mega Creeper Boss class
  class MegaCreeperBoss {
    constructor() {
      let angle = Math.random() * Math.PI * 2;
      let distance = 600;
      this.x = player.x + Math.cos(angle) * distance;
      this.y = player.y + Math.sin(angle) * distance;
      
      this.x = clamp(this.x, 250, W-250);
      this.y = clamp(this.y, 250, H-250);
      
      this.r = 100;
      this.health = 1000 + bossesKilled * 500;
      this.maxHealth = 1000 + bossesKilled * 500;
      this.speed = 0;
      this.color = '#006400';
      this.attackTimer = 0;
      this.attackRate = 1.5;
      this.pulse = 0;
      this.phase = 1;
      this.bulletAngle = 0;
      this.specialAttackTimer = 0;
      this.specialAttackCooldown = 4;
      this.frozen = false;
      this.originalSpeed = 0;
      
      createBossSpawnEffect(this.x, this.y);
    }
    
    update(dt) {
      if (this.frozen) return true;
      
      this.pulse += dt * 4;
      this.specialAttackTimer += dt;
      
      this.r = Math.max(50, 100 * (this.health / this.maxHealth));
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      this.x += toPlayer.x * this.speed * dt;
      this.y += toPlayer.y * this.speed * dt;
      
      if (this.health < this.maxHealth * 0.5 && this.phase === 1) {
        this.phase = 2;
        this.speed = 5;
        this.attackRate = 1.0;
        this.specialAttackCooldown = 2;
      }

      if (this.health < this.maxHealth * 0.1 && this.phase === 2) {
        this.phase = 3;
        this.speed = 20;
        this.attackRate = 0.8;
        this.specialAttackCooldown = 1;
      }
      
      this.attackTimer += dt;
      if (this.attackTimer >= this.attackRate) {
        this.attackTimer = 0;
        
        const bulletCount = this.phase === 1 ? 6 : this.phase === 2 ? 8 : 10;
        
        for (let i = 0; i < bulletCount; i++) {
          const angle = this.bulletAngle + (i / bulletCount) * Math.PI * 2;
          bullets.push({
            x: this.x,
            y: this.y,
            dx: Math.cos(angle),
            dy: Math.sin(angle),
            t: 0,
            life: 2.0 + this.phase,
            speed: 300 - this.phase * 50,
            size: 30 + this.phase * 10,
            color: '#006400',
            enemy: true
          });
        }
        
        this.bulletAngle += 0.2;
        
        sfx(100, 0.2, 0.06, 'sawtooth');
        spawnParticles(this.x, this.y, 'rgba(0,100,0,0.9)', 40, Math.PI*2, 150);
      }
      
      if (this.specialAttackTimer >= this.specialAttackCooldown) {
        this.specialAttackTimer = 0;
        this.specialAttack();
      }
            
      // Remove dead bosses from echoes array
      if (this.health <= 0) {
        const index = echoes.indexOf(this);
        if (index > -1) {
          echoes.splice(index, 1);
        }
        return false;
      }
      return true;    }
    
    specialAttack() {
      // Spawn a ring of bombers around the player
      const bomberCount = 8;
      for (let i = 0; i < bomberCount; i++) {
        const angle = (i / bomberCount) * Math.PI * 2;
        const distance = 150;
        const spawnX = player.x + Math.cos(angle) * distance;
        const spawnY = player.y + Math.sin(angle) * distance;
        
        spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'bomber'));
        
        setTimeout(() => {
          if (running) {
            echoes.push(new Bomber(spawnX, spawnY));
          }
        }, 1000);
      }
      
      shake = 30;
      sfx(80, 0.4, 0.1, 'sawtooth');
      
      spawnParticles(this.x, this.y, 'rgba(0,100,0,0.9)', 80, Math.PI*2, 300);
      spawnParticles(this.x, this.y, 'rgba(0,255,0,0.7)', 60, Math.PI*2, 250);
      spawnParticles(this.x, this.y, 'rgba(100,255,100,0.5)', 40, Math.PI*2, 200);
    }
    
    draw(ctx) {
      const phaseColors = ['#006400', '#228b22', '#32cd32'];
      const pulseSize = this.r * (1 + Math.sin(this.pulse) * 0.15);
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, pulseSize*2);
      g.addColorStop(0, phaseColors[this.phase-1] + 'DD');
      g.addColorStop(1, phaseColors[this.phase-1] + '11');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, pulseSize*2, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = phaseColors[this.phase-1];
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.arc(this.x, this.y, this.r*0.8, 0, Math.PI*2);
      ctx.fill();
      
      // Creeper face
      ctx.fillStyle = 'rgba(0,0,0,0.9)';
      for (let i = 0; i < 4; i++) {
        const row = Math.floor(i / 2);
        const col = i % 2;
        const eyeX = this.x + (col - 0.5) * this.r * 0.4;
        const eyeY = this.y + (row - 0.5) * this.r * 0.4;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, this.r*0.1, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Mouth
      ctx.fillStyle = 'rgba(0,0,0,0.9)';
      ctx.fillRect(
        this.x - this.r*0.3,
        this.y + this.r*0.3,
        this.r*0.6,
        this.r*0.1
      );
      
      if (this.specialAttackTimer > this.specialAttackCooldown - 5) {
        const warningPulse = Math.sin(this.specialAttackTimer * 10) * 0.5 + 0.5;
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,0,${warningPulse})`;
        ctx.lineWidth = 4;
        ctx.arc(this.x, this.y, this.r * 1.5, 0, Math.PI*2);
        ctx.stroke();
      }
    }
    
    takeDamage(amount) {
      this.health -= amount;
      spawnParticles(this.x, this.y, 'rgba(255,255,255,0.9)', 25, Math.PI*2, 150);
      
      if (this.health <= 0) {
        // Spawn enemies on death
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 150;
          const spawnX = this.x + Math.cos(angle) * distance;
          const spawnY = this.y + Math.sin(angle) * distance;
          echoes.push(new Slim(spawnX, spawnY));
        }
        
        for (let i = 0; i < 10; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 100;
          const spawnX = this.x + Math.cos(angle) * distance;
          const spawnY = this.y + Math.sin(angle) * distance;
          echoes.push(new ArmoredSlim(spawnX, spawnY));
        }
        
        for (let i = 0; i < 5; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 50;
          const spawnX = this.x + Math.cos(angle) * distance;
          const spawnY = this.y + Math.sin(angle) * distance;
          echoes.push(new Tank(spawnX, spawnY));
        }
      }
      
      return this.health <= 0;
    }
  }

  // Heat Seeking Rocket class for Final Boss
  class HeatSeekingRocket {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.r = 6;
      this.speed = 150;
      this.life = 12.0;
      this.damage = 3;
      this.target = player;
      this.color = '#ff4500';
      this.trail = [];
    }
    
    update(dt) {
      this.life -= dt;
      
      this.trail.push({x: this.x, y: this.y});
      if (this.trail.length > 8) this.trail.shift();
      
      const aim = vecTo(this.x, this.y, this.target.x, this.target.y);
      this.x += aim.x * this.speed * dt;
      this.y += aim.y * this.speed * dt;
      
      const d = dist({x: this.x, y: this.y}, this.target);
      if (d < this.r + this.target.r) {
        if (shield > 0 && shieldDamageCooldown <= 0) {
          shield--;
          shieldDamageCooldown = 1.0;
        } else if (shield <= 0) {
          player.lives--;
          livesEl.textContent = player.lives;
          player.invul = 1.5;
          shake = 10;
        }
        spawnParticles(this.x, this.y, 'rgba(255,69,0,0.9)', 15, Math.PI*2, 100);
        return false;
      }
      
      if (this.x < -100 || this.x > W+100 || this.y < -100 || this.y > H+100 || this.life <= 0) {
        spawnParticles(this.x, this.y, 'rgba(255,69,0,0.9)', 10, Math.PI*2, 80);
        return false;
      }
      
      return true;
    }
    
    draw(ctx) {
      for (let i = 0; i < this.trail.length; i++) {
        const point = this.trail[i];
        const alpha = i / this.trail.length * 0.5;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,69,0,${alpha})`;
        ctx.arc(point.x, point.y, this.r * (i / this.trail.length), 0, Math.PI*2);
        ctx.fill();
      }
      
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.r*3);
      g.addColorStop(0, 'rgba(255,69,0,0.8)');
      g.addColorStop(1, 'rgba(255,0,0,0.1)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Fire Wave class for Final Boss special attack
  class FireWave {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.radius = 0;
      this.maxRadius = 400;
      this.speed = 200;
      this.damage = 1;
      this.life = 1.0;
      this.color = '#8b0000';
    }
    
    update(dt) {
      this.life -= dt;
      this.radius += this.speed * dt;
      
      // Damage player if caught in wave
      const d = dist({x: this.x, y: this.y}, player);
      if (d < this.radius + player.r && d > this.radius - player.r - 10) {
        if (shield > 0 && shieldDamageCooldown <= 0) {
          shield--;
          shieldDamageCooldown = 1.0;
        } else if (shield <= 0) {
          player.lives--;
          livesEl.textContent = player.lives;
          player.invul = 1.0;
          shake = 8;
        }
      }
      
      // Damage enemies caught in wave
      for (let i = echoes.length - 1; i >= 0; i--) {
        const e = echoes[i];
        const d = dist({x: this.x, y: this.y}, e);
        if (d < this.radius + e.r && d > this.radius - e.r - 10) {
          if (e.takeDamage(this.damage * dt)) {
            echoesKilled++;
            echoes.splice(i, 1);
          }
        }
      }
      
      if (Math.random() < 0.3) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * this.radius;
        const particleX = this.x + Math.cos(angle) * distance;
        const particleY = this.y + Math.sin(angle) * distance;
        
        particles.push({
          x: particleX,
          y: particleY,
          vx: (Math.random()-0.5)*40,
          vy: (Math.random()-0.5)*40,
          life: 0.5 + Math.random() * 0.5,
          col: `rgba(139,0,0,0.8)`,
          r: 2 + Math.random() * 3
        });
      }
      
      return this.life > 0 && this.radius < this.maxRadius;
    }
    
    draw(ctx) {
      const alpha = this.life / 3.0;
      const innerRadius = Math.max(0, this.radius - 20);
      
      const g = ctx.createRadialGradient(this.x, this.y, innerRadius, this.x, this.y, this.radius);
      g.addColorStop(0, `rgba(139,0,0,${alpha * 0.3})`);
      g.addColorStop(1, `rgba(139,0,0,${alpha * 0.1})`);
      
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.arc(this.x, this.y, innerRadius, 0, Math.PI*2, true);
      ctx.fill();
      
      ctx.strokeStyle = `rgba(255,0,0,${alpha * 0.7})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  // particle system
  function spawnParticles(x,y,color,n=12,spread=Math.PI,force=120){
    for(let i=0;i<n;i++){
      const ang = rand(-spread/2, spread/2) + rand(0,Math.PI*2);
      const s = rand(0.3,1.2);
      particles.push({x,y,vx:Math.cos(ang)*force*s, vy:Math.sin(ang)*force*s, life:rand(0.4,0.9), col:color, r: rand(1.5,4)});
    }
  }

  // Boss spawn effect
  function createBossSpawnEffect(x, y) {
    bossSpawnEffect = {
      x: x,
      y: y,
      timer: 1.5,
      maxTimer: 1.5
    };
    
    shake = 20;
    sfx(80, 1.0, 0.1, 'sawtooth');
    
    spawnParticles(x, y, 'rgba(255,0,0,0.9)', 100, Math.PI*2, 300);
    spawnParticles(x, y, 'rgba(255,100,0,0.7)', 80, Math.PI*2, 250);
    spawnParticles(x, y, 'rgba(255,255,0,0.5)', 60, Math.PI*2, 200);
  }

  // Upgrade class
  class Upgrade {
    constructor(type){
      let angle = Math.random() * Math.PI * 2;
      let distance = 150 + Math.random() * 100;
      this.x = player.x + Math.cos(angle) * distance;
      this.y = player.y + Math.sin(angle) * distance;
      
      this.x = clamp(this.x, 30, W-30);
      this.y = clamp(this.y, 30, H-30);
      
      this.r = 16;
      this.type = type;
      this.colors = {
        fireRate: '#4dabf7', // Blue
        bulletSpeed: '#4dabf7', // Blue
        movement: '#7ee787', // Green
        knockback: '#ffd43b', // Yellow
        bulletSize: '#da77f2', // Pink/Purple
        bulletLife: '#69db7c', // Bright Green
        xpBoost: '#00ffaa', // Bright Cyan-Green
        extraLife: '#ff8787', // Light Red
        workers: '#63e6be', // Teal
        ghost: '#a78bfa', // Lavender
        holyLife: '#ff6b6b', // Coral Red
        killBoost: '#ffd700', // Gold
        boomerang: '#ff6b6b', // Red
        fire: '#ff4757', // Vivid Red
        shotgun: '#00ffaa', // Bright Cyan-Green
        shield: '#4dabf7', // Blue
        shieldRegen: '#74c0fc', // Light Blue
        health: '#ff8787', // Light Red
        damage: '#ff6b6b', // Red
        sprint: '#7ee787', // Green
        rocket: '#ff6b6b', // Red
        powerBullet: '#ff6b6b', // Red
        knockbackBullets: '#ffd43b', // Yellow
        workerCollector: '#63e6be', // Teal
        flanker: '#74c0fc', // Light Blue
        shockwave: '#da70d6', // Orchid Purple
        guards: '#ff6b6b', // Red
        freeze: '#4dabf7', // Blue
        lastResort: '#8b00b5', // purple
        music: '#ff00ff', // Magenta
        damageZone: '#ff6b6b', // Red
        minigun: '#00ffaa', // Bright Cyan-Green
        saferSpaces: '#00ffff', // Cyan
        mineCount: '#00ffaa', // Bright Cyan-Green
        cooldownRefresh: '#00ffaa', // Bright Cyan-Green
        reflectiveMirror: '#aaffff', // Pale Cyan
        lightningStrike: '#636bff' // Indigo Blue
      };
      // Level 1: Orbs last 5 seconds longer
      this.life = player.stats.xpBoost.level === 1 ? 20 : 15;
            this.float = 0;
          }
    
    draw(ctx){
      this.float += 0.05;
      const floatY = Math.sin(this.float) * 3;
      
      const g = ctx.createRadialGradient(this.x, this.y + floatY, 1, this.x, this.y + floatY, this.r*3);
      g.addColorStop(0, this.colors[this.type] + 'DD');
      g.addColorStop(1, this.colors[this.type] + '11');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y + floatY, this.r*2.5, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath(); 
      ctx.fillStyle = this.colors[this.type];
      ctx.arc(this.x, this.y + floatY, this.r, 0, Math.PI*2); 
      ctx.fill();
      
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 14px sans-serif';
      
      const icons = {
        fireRate: 'xp', bulletSpeed: 'âž¤', movement: 'xp',
        knockback: 'xp', bulletSize: 'â—', bulletLife: 'â—',
        xpBoost: 'xp', extraLife: 'â—', workers: 'â—',
        ghost: 'xp',
        holyLife: 'xp', killBoost: 'xp',
        boomerang: 'xp', fire: 'xp', shotgun: 'xp',
        shield: 'xp', shieldRegen: 'xp', health: 'xp', damage: 'xp',
        sprint: 'xp', rocket: 'xp',
        powerBullet: 'xp',
        knockbackBullets: 'xp',
        workerCollector: 'xp',
        flanker: 'âž¤',
        shockwave: 'xp',
        guards: 'ðŸ›¡ï¸',
        freeze: 'â„',
        lastResort: 'ðŸ›¡ï¸',
        music: 'xp',
        damageZone: 'âš”',
        minigun: 'xp',
        saferSpaces: 'ðŸ›¡ï¸',
        mineCount: 'xp',
        cooldownRefresh: 'â±',
        reflectiveMirror: 'ðŸ›¡ï¸',
        lightningStrike: 'xp'
      };
      
      ctx.fillText(icons[this.type], this.x, this.y + floatY);
    }
    
    update(dt){
      this.life -= dt;
      return this.life > 0;
    }

    checkXPOrbPulling() {
        // Level 2: Pull all close XP orbs toward the player
        if (player.stats.xpBoost.level === 2) {
            const pullRadius = 200; // Radius within which orbs get pulled
            const pullSpeed = 100; // Speed at which orbs move toward player
            
            for (const u of upgrades) {
                if (u.type === 'xpBoost') {
                    const d = dist({x: u.x, y: u.y}, player);
                    if (d < pullRadius) {
                        const toPlayer = vecTo(u.x, u.y, player.x, player.y);
                        u.x += toPlayer.x * pullSpeed * 0.016; // Assuming 60 FPS
                        u.y += toPlayer.y * pullSpeed * 0.016;
                    }
                }
            }
        }
    }

  }

  // Echo class - FIXED: Speed cap in endless mode
  class Echo {
    constructor(spawnX, spawnY){
      this.x = spawnX;
      this.y = spawnY;
      this.r = player.r*0.95;
      this.alive = true; 
      this.state = 'hunt'; 
      this.aggro = 0; 
      this.color = '#ff6b6b';
      this.chargeTimer = 0;
      this.speed = 40;
      this.maxSpeed = 350; // Capped at 350 even in endless mode
      this.age = 0;
      this.health = 3;
      this.maxHealth = 3;
      this.hitTimer = 0;
      this.collisionDamage = 1;
      this.rocketDamage = 0;
      this.rocketDamageTimer = 0;
      this.frozen = false;
      this.originalSpeed = 40;
      this.knockbackTimer = 0;
      this.knockbackX = 0;
      this.knockbackY = 0;
    }
    
    update(dt){
      if (this.frozen) return true;
      
      this.age += dt;
      this.hitTimer -= dt;
      this.rocketDamageTimer += dt;
      this.knockbackTimer -= dt;
      
      if (this.rocketDamage > 0 && this.rocketDamageTimer >= 0.25) {
        this.rocketDamageTimer = 0;
        this.takeDamage(this.rocketDamage);
        this.rocketDamage = Math.max(0, this.rocketDamage - 1);
      }
      
      // FIX: Speed cap in endless mode - never exceeds 350
      this.speed = Math.min(this.maxSpeed, 40 + this.age * 3);
      if (endlessMode) {
        this.speed = Math.min(this.speed, 350); // Hard cap at 350
      }
      
      const toPlayer = vecTo(this.x, this.y, player.x, player.y);
      const d = toPlayer.mag;
      
      this.aggro = clamp(this.aggro + (d < 220 ? dt*0.9 : dt*0.08), 0, 1.6);
      
      for (const other of echoes) {
        if (other !== this) {
          const dx = this.x - other.x;
          const dy = this.y - other.y;
          const distance = Math.hypot(dx, dy);
          const minDistance = this.r + other.r;
          
          if (distance < minDistance) {
            const angle = Math.atan2(dy, dx);
            const force = (minDistance - distance) * 0.5;
            this.x += Math.cos(angle) * force;
            this.y += Math.sin(angle) * force;
            other.x -= Math.cos(angle) * force;
            other.y -= Math.cos(angle) * force;
          }
        }
      }
      
      this.chargeTimer += dt;
      let speed = this.speed + 30 * difficulty + (this.aggro*60);
      
      // Apply knockback
      if (this.knockbackTimer > 0) {
        this.x += this.knockbackX * dt;
        this.y += this.knockbackY * dt;
        speed *= 0.5; // Slow down during knockback
      } else {
        this.x += toPlayer.x * speed * dt;
        this.y += toPlayer.y * speed * dt;
      }
      
      if (this.chargeTimer > 1.6){
        this.x += toPlayer.x * 150 * dt;
        this.y += toPlayer.y * 150 * dt;
        this.chargeTimer = 0;
        spawnParticles(this.x, this.y, 'rgba(255,80,80,0.9)', 10, Math.PI/3, 90);
        sfx(320, 0.06, 0.03, 'sawtooth');
      }
      
      this.x = clamp(this.x, this.r, W - this.r);
      this.y = clamp(this.y, this.r, H - this.r);
      
      // FIX: If speed exceeds cap in endless mode, convert to slim
      if (endlessMode && this.speed > 350 && this instanceof Echo) {
        const slim = new Slim(this.x, this.y);
        echoes.push(slim);
        const index = echoes.indexOf(this);
        if (index > -1) {
          echoes.splice(index, 1);
        }
        spawnParticles(this.x, this.y, 'rgba(255,149,0,0.9)', 10, Math.PI*2, 80);
        return false;
      }
      
      return this.health > 0;
    }
    
    draw(ctx){
      const hitEffect = this.hitTimer > 0 ? Math.sin(this.hitTimer * 20) * 0.5 + 0.5 : 0;
      const hitColor = hitEffect > 0 ? `rgb(255, ${255 - hitEffect * 200}, ${255 - hitEffect * 200})` : '#ff5454';
      
      const g = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, this.r*3);
      g.addColorStop(0, 'rgba(255,110,110,0.95)');
      g.addColorStop(1, 'rgba(255,80,80,0.03)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath(); ctx.fillStyle = hitColor; ctx.arc(this.x, this.y, this.r*0.6, 0, Math.PI*2); ctx.fill();
      
      if (this.health < this.maxHealth) {
        const barWidth = this.r * 1.5;
        const barHeight = 4;
        const barX = this.x - barWidth/2;
        const barY = this.y - this.r - 8;
        
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        ctx.fillStyle = this.health > this.maxHealth/2 ? '#7ee787' : '#ff9e44';
        ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
      }
      
      ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.9)'; ctx.ellipse(this.x - this.r*0.22, this.y - this.r*0.08, this.r*0.18, this.r*0.25, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(this.x + this.r*0.22, this.y - this.r*0.08, this.r*0.18, this.r*0.25, 0, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.arc(this.x - this.r*0.26, this.y - this.r*0.14, this.r*0.06, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(this.x + this.r*0.18, this.y - this.r*0.14, this.r*0.06, 0, Math.PI*2); ctx.fill();
    }
    
    takeDamage(amount) {
      this.health -= amount;
      this.hitTimer = 0.3;
      spawnParticles(this.x, this.y, 'rgba(255,255,255,0.9)', 8, Math.PI*2, 60);
      
      // FIXED: Knockback bullets - third upgrade can push back multiple enemies
      if (player.stats.knockbackBullets.level > 0) {
        const knockbackForce = player.stats.knockbackBullets.level === 1 ? 30 : 
                              player.stats.knockbackBullets.level === 2 ? 60 : 100;
        const toEnemy = vecTo(player.x, player.y, this.x, this.y);
        
        // For third upgrade, apply knockback to multiple enemies
        if (player.stats.knockbackBullets.level >= 3) {
          for (const e of echoes) {
            const d = dist({x: this.x, y: this.y}, e);
            if (d < 50) { // Area effect for third upgrade
              const toOther = vecTo(player.x, player.y, e.x, e.y);
              e.knockbackX = toOther.x * knockbackForce;
              e.knockbackY = toOther.y * knockbackForce;
              e.knockbackTimer = 0.5;
              
              // Freeze for 0.5 seconds with mythical upgrade
              if (player.stats.knockbackBullets.level >= 4) {
                e.frozen = true;
                e.originalSpeed = e.speed;
                e.speed = 0;
                setTimeout(() => {
                  if (e.originalSpeed !== undefined) {
                    e.speed = e.originalSpeed;
                    e.frozen = false;
                  }
                }, 500);
              }
            }
          }
        } else {
          // Standard knockback for first two upgrades
          this.knockbackX = toEnemy.x * knockbackForce;
          this.knockbackY = toEnemy.y * knockbackForce;
          this.knockbackTimer = 0.5;
        }
      }
      
      if (this.health <= 0 && player.stats.ghost.level > 0) {
        const ghostChance = player.stats.ghost.level === 1 ? 0.25 : 
                           player.stats.ghost.level === 2 ? 0.4 : 0.5;
        
        if (Math.random() < ghostChance) {
          const ghost = new Ghost(this.x, this.y);
          
          if (player.stats.ghost.level >= 2) {
            ghost.speed == 150;
            ghost.damage == 2;
          }
          if (player.stats.ghost.level >= 3) {
            ghost.speed == 160;
            ghost.damage == 3;
          }
          
          ghosts.push(ghost);
        }
      }
      
      if (this.health <= 0 && player.stats.killBoost.level > 0) {
        killBoostTimer = player.stats.killBoost.level === 1 ? 3 : 
                        player.stats.killBoost.level === 2 ? 5 : 6;
      }
      
      return this.health <= 0;
    }
  }

  // spawn functions
  function spawnEchoFromOutside(){
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    switch(side) {
      case 0:
        spawnX = Math.random() * W;
        spawnY = -50;
        break;
      case 1:
        spawnX = W + 50;
        spawnY = Math.random() * H;
        break;
      case 2:
        spawnX = Math.random() * W;
        spawnY = H + 50;
        break;
      case 3:
        spawnX = -50;
        spawnY = Math.random() * H;
        break;
    }
    
    spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'normal'));
    
    setTimeout(() => {
      if (running) {
        echoes.push(new Echo(spawnX, spawnY));
        playSound('enemySpawn');
      }
    }, 1000);
    
    echoCountEl.textContent = echoes.length;
  }

    function spawnRandomEnemy() {
    // Spawn bosses as regular enemies in endless mode after certain times
    if (endlessMode) {
      if (timeAlive > 600 && Math.random() < 0.015) {
        echoes.push(new MegaCreeperBoss());
        return;
      } else if (timeAlive > 550 && Math.random() < 0.02) {
        echoes.push(new HardBoss());
        return;
      } else if (timeAlive > 500 && Math.random() < 0.03) {
        echoes.push(new MediumBoss());
        return;
      } else if (timeAlive > 450 && Math.random() < 0.04) {
        echoes.push(new EasyBoss());
        return;
      }
      
      // In endless mode (after final boss), spawn witches more frequently
      if (Math.random() < 0.16) { // 16% chance to spawn witch in endless mode
        spawnWitchFromOutside();
        return;
      }
      
      // Spawn armored slims after final Boss
      if (bossesKilled >= 3 && Math.random() < 0.05) {
        spawnArmoredSlimFromOutside();
        return;
      }
    }
    
    if (timeAlive < 10 && Math.random() < 0.3) {
      spawnSlimFromOutside();
      return;
    }
    
    const randVal = Math.random();
    
    if (timeAlive > 50 && randVal < 0.03) {
      spawnsniperFromOutside();
    } else if (timeAlive > 50 && randVal < 0.2) {
      spawnBomberFromOutside();
    } else if (timeAlive > 70 && randVal < 0.05) { 
      spawnWitchFromOutside();
    } else if (timeAlive > 20 && randVal < 0.05) {
      spawnTankFromOutside();
    } else if (timeAlive > 30 && randVal < 0.15) {
      spawnBowFromOutside();
    } else {
      spawnEchoFromOutside();
    }
  }

  function spawnSlimFromOutside() {
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    switch(side) {
      case 0: spawnX = Math.random() * W; spawnY = -30; break;
      case 1: spawnX = W + 30; spawnY = Math.random() * H; break;
      case 2: spawnX = Math.random() * W; spawnY = H + 30; break;
      case 3: spawnX = -30; spawnY = Math.random() * H; break;
    }
    
    spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'slim'));
    
    setTimeout(() => {
      if (running) {
        echoes.push(new Slim(spawnX, spawnY));
        playSound('slimSpawn');
      }
    }, 800);
    
    echoCountEl.textContent = echoes.length;
  }

  // NEW: Spawn Armored Slim
  function spawnArmoredSlimFromOutside() {
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    switch(side) {
      case 0: spawnX = Math.random() * W; spawnY = -40; break;
      case 1: spawnX = W + 40; spawnY = Math.random() * H; break;
      case 2: spawnX = Math.random() * W; spawnY = H + 40; break;
      case 3: spawnX = -40; spawnY = Math.random() * H; break;
    }
    
    spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'armoredSlim'));
    
    setTimeout(() => {
      if (running) {
        echoes.push(new ArmoredSlim(spawnX, spawnY));
        playSound('enemySpawn');
      }
    }, 1000);
    
    echoCountEl.textContent = echoes.length;
  }

  function spawnTankFromOutside() {
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    switch(side) {
      case 0: spawnX = Math.random() * W; spawnY = -60; break;
      case 1: spawnX = W + 60; spawnY = Math.random() * H; break;
      case 2: spawnX = Math.random() * W; spawnY = H + 60; break;
      case 3: spawnX = -60; spawnY = Math.random() * H; break;
    }
    
    spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'tank'));
    
    setTimeout(() => {
      if (running) {
        echoes.push(new Tank(spawnX, spawnY));
        playSound('enemySpawn');
      }
    }, 1200);
    
    echoCountEl.textContent = echoes.length;
  }

  function spawnBowFromOutside() {
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    switch(side) {
      case 0: spawnX = Math.random() * W; spawnY = -40; break;
      case 1: spawnX = W + 40; spawnY = Math.random() * H; break;
      case 2: spawnX = Math.random() * W; spawnY = H + 40; break;
      case 3: spawnX = -40; spawnY = Math.random() * H; break;
    }
    
    spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'bow'));
    
    setTimeout(() => {
      if (running) {
        echoes.push(new Bow(spawnX, spawnY));
        playSound('enemySpawn');
      }
    }, 1000);
    
    echoCountEl.textContent = echoes.length;
  }

  function spawnWitchFromOutside() {
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    switch(side) {
      case 0: spawnX = Math.random() * W; spawnY = -50; break;
      case 1: spawnX = W + 50; spawnY = Math.random() * H; break;
      case 2: spawnX = Math.random() * W; spawnY = H + 50; break;
      case 3: spawnX = -50; spawnY = Math.random() * H; break;
    }
    
    spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'witch'));
    
    setTimeout(() => {
      if (running) {
        echoes.push(new Witch(spawnX, spawnY));
        playSound('enemySpawn');
      }
    }, 1500);
    
    echoCountEl.textContent = echoes.length;
  }

  // Spawn sniper
  function spawnsniperFromOutside() {
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    switch(side) {
      case 0: spawnX = Math.random() * W; spawnY = -80; break;
      case 1: spawnX = W + 80; spawnY = Math.random() * H; break;
      case 2: spawnX = Math.random() * W; spawnY = H + 80; break;
      case 3: spawnX = -80; spawnY = Math.random() * H; break;
    }
    
    spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'sniper'));
    
    setTimeout(() => {
      if (running) {
        echoes.push(new sniper(spawnX, spawnY));
        playSound('enemySpawn');
      }
    }, 2000);
    
    echoCountEl.textContent = echoes.length;
  }

  // Spawn Bomber
  function spawnBomberFromOutside() {
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    switch(side) {
      case 0: spawnX = Math.random() * W; spawnY = -40; break;
      case 1: spawnX = W + 40; spawnY = Math.random() * H; break;
      case 2: spawnX = Math.random() * W; spawnY = H + 40; break;
      case 3: spawnX = -40; spawnY = Math.random() * H; break;
    }
    
    spawnIndicators.push(new SpawnIndicator(spawnX, spawnY, 'bomber'));
    
    setTimeout(() => {
      if (running) {
        echoes.push(new Bomber(spawnX, spawnY));
        playSound('enemySpawn');
      }
    }, 1000);
    
    echoCountEl.textContent = echoes.length;
  }

  // Sprint function
  function updateSprint(dt) {
    if (player.stats.sprint.level === 0) return;
    
    const isShooting = input.mouseDown || player.autoFireToggle;
    
    if (!isShooting) {
      sprintTimer += dt;
      
      const speedBonus = player.stats.sprint.level === 1 ? 0.5 : 
                        player.stats.sprint.level === 2 ? 0.75 : 1;
      player.speed = 250 * (1 + speedBonus);
      
      // Healing for sprint upgrades 1 and 2
      if (player.stats.sprint.level >= 1) {
        const healTimer = 15; // Heal every 15 seconds for level 1
        if (sprintTimer >= healTimer) {
          sprintTimer = 0;
          if (player.lives < 10) {
            player.lives += 1; // Heal 1 HP for level 1
            livesEl.textContent = player.lives;
            playSound('heal');
            spawnParticles(player.x, player.y, 'rgba(126,231,135,0.9)', 15, Math.PI*2, 80);
          }
        }
      }
      
      // Sprint upgrade 2: Enhanced healing (every 10 seconds)
      if (player.stats.sprint.level >= 2 && sprintTimer >= 10.0) {
        sprintTimer = 0;
        if (player.lives < 10) {
          player.lives += 1; // Heal 1 HP for level 2
          livesEl.textContent = player.lives;
          playSound('heal');
          spawnParticles(player.x, player.y, 'rgba(126,231,135,0.9)', 15, Math.PI*2, 80);
        }
      }

      // Sprint upgrade 3
      if (player.stats.sprint.level >= 3 && sprintTimer >= 8.0) {
        sprintTimer = 0;
        if (player.lives < 100) { // 100hp cap for level 3
          player.lives++;
          livesEl.textContent = player.lives;
          playSound('heal');
          spawnParticles(player.x, player.y, 'rgba(126,231,135,0.9)', 15, Math.PI*2, 80);
        }
      }
    } else {
      sprintTimer = 0;
      player.speed = 250;
    }
  }

    // Update passive damage zone
    if (damageZoneActive) {
      damageZoneAngle += dt * 5;
      
      // Get damage and area multipliers
      const damageMultiplier = player.stats.damageZone.level === 2 ? 1.3 : 1.0;
      const areaMultiplier = player.stats.damageZone.level === 2 ? 1.5 : 1.0;
      const baseDamage = 1.5 * player.damageMultiplier; // Scales with player damage
      
      // Damage enemies in the zone - affects all enemies within range
      for (let i = echoes.length - 1; i >= 0; i--) {
        const e = echoes[i];
        const d = dist({x: player.x, y: player.y}, e);
        if (d < player.r * 6 * areaMultiplier) { // 6x player radius area
          if (e.takeDamage(baseDamage * damageMultiplier * dt)) {
            if (gameMode !== 'freemode' || player.lives > 0) {
              score += 5;
            }
            echoesKilled++;
            spawnParticles(e.x, e.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
            echoes.splice(i, 1);
            echoCountEl.textContent = echoes.length;
          }
        }
      }
    }

  // Reset
  function resetGame(){
    player.x = W/2; player.y = H/2; player.vx = player.vy = 0; player.invul = 0;
    player.trail = [];
    player.workers = [];

    // Reset ability tracking
    emergencyAbility = 'mineLayer';
    selectedAbilities = new Set(['mineLayer']);
        
  // Set initial lives based on game mode
  if (gameMode === 'hardcore') {
    player.lives = 1;
    // Apply hardcore starting stats
    setHardcoreStartingStats();
  } else if (gameMode === 'freemode') {
    player.lives = 8;
    // Give 3 random upgrades in freemode
    for (let i = 0; i < 3; i++) {
      const availableTypes = [];
      for (const stat in player.stats) {
        if (player.stats[stat].level < player.stats[stat].max) {
          availableTypes.push(stat);
        }
      }
      
      if (availableTypes.length > 0) {
        const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        player.stats[type].level++;
      }
    }
    
    // Ensure worker collector works in freemode
    if (player.stats.workerCollector.level > 0) {
      const worker = new WorkerCollector();
      player.workers.push(worker);
    }
  } else {
    player.lives = 3;
  }    
    playerLevel = 1;
    playerXP = 0;
    xpToNextLevel = 100;
    records.length = echoes.length = bullets.length = paints.length = particles.length = upgrades.length = ghosts.length = bombs.length = fires.length = rockets.length = spawnIndicators.length = shockwaves.length = guards.length = minigunBullets.length = 0;
    timeAlive = 0; score = 0; difficulty = 1; shake = 0;
    echoesKilled = 0; upgradesGathered = 0; bossesKilled = 0; megaBossActive = false;
    recordTimer = 0; echoSpawnTimer = 0; fireTimer = 0; autoFireTimer = 0; workerFireTimer = 0; bossSpawnTimer = 0;
    upgradeAvailable = false;
    lastMouseMove = performance.now();
    player.autoAim = true;
    player.autoFireToggle = true;
    bossSpawnEffect = null;
    upgradeSelectionCooldown = 0;
    killBoostTimer = 0;
    pendingUpgrades = 1;
    tabPressed = false;
    gamePaused = false;
    shield = 0;
    shieldTimer = 0;
    shieldDamageCooldown = 0;
    bulletCounter = 0;
    if (window.lightningCounter) window.lightningCounter = 0;
    sprintTimer = 0;
    endlessMode = false;
    bossUpgradePending = false;
    mythicalDropTimer = 0;
    maxLevelReached = false;
    refreshUsed = false;
    damageZoneActive = false;
    damageZoneTimer = 0;
    damageZoneAngle = 0;
    minigunActive = false;
    minigunTimer = 0;
    saferSpacesActive = false;
    saferSpacesTimer = 0;
    saferSpacesHealth = 5;
    saferSpacesWall = null;

    reflectiveMirrorActive = false;
    reflectiveMirrorRadius = 55;
    reflectiveMirrorChance = 0.3;
    reflectiveMirrorPulse = 0;

    bossHealth.style.display = 'none';
    levelUpNotification.style.display = 'none';
    upgradeMenu.style.display = 'none';
    pauseMenu.style.display = 'none';
    abilityCooldown.style.display = 'none';
    freezeOverlay.style.display = 'none';
    
    commonChance = 70;
    rareChance = 30;
    legendaryChance = 0;
    mythicalChance = 0;
    lastChanceUpdate = 0;
    
    emergencyAbility = 'mineLayer';
    emergencyAbilityCooldown = 0;
    emergencyAbilityActive = false;
    emergencyAbilityTimer = 0;
    tripleShotBullets = 0;
    freezeActive = false;
    freezeTimer = 0;
    lastResortActive = false;
    lastResortTimer = 0;
    guardsActive = false;
    guardsTimer = 0;
    shockwaveActive = false;
    shockwaveTimer = 0;
    shockwaveRadius = 0;
    shockwaveDamage = 0;
    
    // Reset stats based on game mode
    if (gameMode !== 'freemode') {
      for (const stat in player.stats) {
        player.stats[stat].level = 0;
      }
    }
    
    // In hardcore mode, remove extra life and shield upgrades
    if (gameMode === 'hardcore') {
      player.stats.extraLife.max = 0;
      player.stats.shield.max = 0;
      player.stats.health.max = 0;
      player.stats.holyLife.max = 0;
    } else {
      player.stats.extraLife.max = 1;
      player.stats.shield.max = 3;
      player.stats.health.max = 2;
      player.stats.holyLife.max = 1;
    }
    updateUI();

    // Reset boss tracking
    bossSpawnSchedule = [
      { time: 30, type: 'easy', spawned: false, killed: false },
      { time: 70, type: 'medium', spawned: false, killed: false },
      { time: 120, type: 'hard', spawned: false, killed: false },
      { time: 200, type: 'final', spawned: false, killed: false },
      { time: 350, type: 'creeper', spawned: false, killed: false }
    ];
    activeBosses = [];
    bossHealthBars = [];
    bossSpawnTimer = 0;
    endlessMode = false;


  }

  // Start game
  function startGame(mode){
    updateBackgroundForGameMode(mode);
    gameMode = mode;
    
    // First, reset the game immediately to clear any existing XP orbs
    resetGame();
    
    // Add fade-out transition to start screen
    startScreen.classList.add('hidden');
    
    // After transition completes, start the game
    setTimeout(() => {
      startScreen.style.display = 'none';
      deathScreen.style.display = 'none';
      upgradeMenu.style.display = 'none';
      pauseMenu.style.display = 'none';
      levelUpNotification.style.display = 'none';
      
      // Now set the game as started and running
      gameStarted = true;
      running = true;
      
      audioResume();
      playbackgroundsong();
      
      // Add a subtle fade-in effect for the game canvas
      canvas.style.opacity = '0';
      canvas.style.transition = 'opacity 0.3s ease';
      setTimeout(() => {
        canvas.style.opacity = '1';
      }, 50);
    }, 200); // Wait for CSS transition to complete 
  }

  document.getElementById('restart').addEventListener('click', () => { 
    if (confirm("Are you sure you want to restart? All progress will be lost.")) {
      resetGame();
      startGame(gameMode);
    }
  });
  classicBtn.addEventListener('click', () => { startGame('classic'); });
  hardcoreBtn.addEventListener('click', () => { startGame('hardcore'); });
  freemodeBtn.addEventListener('click', () => { startGame('freemode'); });
  
  restartFromDeath.addEventListener('click', () => { 
    if (confirm("Refresh the game to start a new run?")) {
      location.reload();
    }
  });
  resumeBtn.addEventListener('click', () => { 
    gamePaused = false;
    hidePauseMenu();
  });
  refreshUpgrades.addEventListener('click', () => {
    if (!refreshUsed) {
      refreshUsed = true;
      refreshUpgrades.disabled = true;
      refreshUpgrades.textContent = 'REFRESH (0/1)';
      showUpgradeMenu();
    }
  });

  // Update Log Panel functionality
  const updateLogPanel = document.getElementById('updateLogPanel');
  const newFeatureBtn = document.getElementById('newFeatureBtn');
  const closeUpdateLog = document.getElementById('closeUpdateLog');

  newFeatureBtn.addEventListener('click', () => {
    updateLogPanel.style.display = 'block';
    audioResume();
  });

  closeUpdateLog.addEventListener('click', () => {
    updateLogPanel.style.display = 'none';
  });

  // Close update log when clicking outside
  updateLogPanel.addEventListener('click', (e) => {
    if (e.target === updateLogPanel) {
      updateLogPanel.style.display = 'none';
    }
  });

  // Close update log with Escape key
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && updateLogPanel.style.display === 'block') {
      updateLogPanel.style.display = 'none';
    }
  });

  // Show pause menu
  function showPauseMenu() {
    pauseMenu.style.display = 'block';
    upgradesList.innerHTML = '';
    
    // Add current upgrades to the list
    for (const stat in player.stats) {
      if (player.stats[stat].level > 0) {
        const item = document.createElement('div');
        item.className = 'upgrade-item';
        item.innerHTML = `
          <div class="upgrade-name">${getUpgradeTitle(stat)}</div>
          <div class="upgrade-level">${player.stats[stat].level}/${player.stats[stat].max}</div>
        `;
        upgradesList.appendChild(item);
      }
    }
    
    // Add emergency ability options
    const abilityItem = document.createElement('div');
    abilityItem.className = 'upgrade-item';
    const abilityNames = {
      mineLayer: 'MINE LAYER',      
      shockwave: 'SHOCKWAVE',
      guards: 'GUARDS',
      freeze: 'FREEZE',
      lastResort: 'LAST RESORT',
      damageZone: 'DAMAGE ZONE',
      saferSpaces: 'SAFER SPACES',
      lightningStrike: 'LIGHTNING STRIKE'
    };
    abilityItem.innerHTML = `
      <div class="upgrade-name">Emergency Ability</div>
      <div class="upgrade-level">${abilityNames[emergencyAbility]}</div>
    `;
    upgradesList.appendChild(abilityItem);
  }

  function hidePauseMenu() {
    pauseMenu.style.display = 'none';
  }

  // bullets: with recoil effect and bomb chance
  function fireShot(){
    const rocketLevel = player.stats.rocket.level;
    let isRocket = false;
    
    if (rocketLevel > 0) {
      const rocketChance = rocketLevel === 1 ? 0.5 : 0.2;
      if (Math.random() < rocketChance) {
        isRocket = true;
      }
    }
    
    const lightningStrikeLevel = player.stats.lightningStrike.level;
    let isLightningStrike = false;

    if (lightningStrikeLevel > 0) {
      // Use separate counter for lightning strike
      if (!window.lightningCounter) window.lightningCounter = 0;
      window.lightningCounter++;
      if (window.lightningCounter >= 4) {
        isLightningStrike = true;
        window.lightningCounter = 0;
      }
    }

    // Fire lightning strike as extra, not replacement
    if (isLightningStrike && lightningStrikeLevel > 0) {
      const lightningDamage = 2 * player.damageMultiplier;
      lightningStrikes.push(new LightningStrike(player.x, player.y, lightningDamage));
      playSound('shockwave');
      spawnParticles(player.x, player.y, 'rgba(255,255,200,0.9)', 20, Math.PI*2, 150);
    }

    const fireLevel = player.stats.fire.level;
    let isFire = false;

    if (fireLevel > 0) {
      bulletCounter++;
      if (bulletCounter >= 5) {
        isFire = true;
        bulletCounter = 0;
      }
    }
    
    const shotgunLevel = player.stats.shotgun.level;
    let shotgunBullets = 0;
    let shotgunInterval = 0;
    
    if (shotgunLevel > 0) {
      if (shotgunLevel === 1) shotgunInterval = 3;
      else if (shotgunLevel === 2) shotgunInterval = 2;
      else if (shotgunLevel === 3) shotgunInterval = 2;
      else if (shotgunLevel === 4) shotgunInterval = 1;
      else if (shotgunLevel === 5) shotgunInterval = 1;
      
      if (shotgunLevel === 1) shotgunBullets = 2;
      else if (shotgunLevel === 2) shotgunBullets = 2;
      else if (shotgunLevel === 3) shotgunBullets = 4;
      else if (shotgunLevel === 4) shotgunBullets = 4;
      else if (shotgunLevel === 5) shotgunBullets = 8;
    }
    
    const flankerLevel = player.stats.flanker.level;
    let isFlanker = false;
    let flankerBullets = 0;
    let flankerAngle = Math.PI / 12;

    if (flankerLevel > 0) {
      // activation timing - FIXED: Proper activation conditions
      let canActivate = false;
      
      if (flankerLevel === 1) {
        // Level 1: Every 3rd bullet
        canActivate = (bulletCounter % 2 === 0);
      } else if (flankerLevel === 2) {
        // Level 2: Every 2nd bullet  
        canActivate = (bulletCounter % 2 === 0);
      } else if (flankerLevel === 3) {
        // Level 3: Every bullet
        canActivate = true;
      } else if (flankerLevel === 4) {
        // Level 4: Every bullet + more bullets
        canActivate = true;
      } else if (flankerLevel >= 5) {
        // Level 5+: Every bullet with increased count
        canActivate = true;
      }

      if (canActivate) {
        isFlanker = true;

        // FIXED: Proper bullet count per level
        flankerBullets =
          flankerLevel === 1 ? 2 :
          flankerLevel === 2 ? 4 :
          flankerLevel === 3 ? 4 :
          flankerLevel === 4 ? 6 :
          flankerLevel === 5 ? 7 :
          flankerLevel === 6 ? 8 :
          flankerLevel === 7 ? 10 : 0;
        
        // FIXED: Proper spread angle based on level
        flankerAngle = 
          flankerLevel === 1 ? Math.PI / 12 :  // 15 degrees
          flankerLevel === 2 ? Math.PI / 9 :   // 20 degrees
          flankerLevel === 3 ? Math.PI / 8 :   // 22.5 degrees
          flankerLevel === 4 ? Math.PI / 4 :   // 45 degrees - wider spread
          flankerLevel === 5 ? Math.PI / 3 :   // 60 degrees
          flankerLevel === 6 ? Math.PI / 2.5 : // ~72 degrees
          Math.PI / 2;                         // 90 degrees
      }
    }    
    const powerBulletLevel = player.stats.powerBullet.level;
    let isPowerBullet = false;
    let powerBulletMultiplier = 1;
    
    if (powerBulletLevel > 0) {
      if (powerBulletLevel === 1 && bulletCounter % 4 === 0) {
        isPowerBullet = true;
        powerBulletMultiplier = 2;
      } else if (powerBulletLevel === 2 && bulletCounter % 3 === 0) {
        isPowerBullet = true;
        powerBulletMultiplier = 3;
      } else if (powerBulletLevel === 3 && bulletCounter % 2 === 0) {
        isPowerBullet = true;
        powerBulletMultiplier = 4;
      }
    }
    
    let aim;
    if (player.autoAim) {
      let nearest = null;
      let nearestDist = Infinity;
      for (const e of echoes) {
        const d = dist({x: player.x, y: player.y}, e);
        if (d < nearestDist) {
          nearest = e;
          nearestDist = d;
        }
      }
      if (nearest) {
        aim = vecTo(player.x, player.y, nearest.x, nearest.y);
      } else {
        aim = {x: 1, y: 0};
      }
    } else {
      aim = vecTo(player.x, player.y, input.mx, input.my);
    }
    
    // Fire rocket as extra, not replacement
    if (isRocket && rocketLevel > 0) {
      const rocket = new Rocket(player.x, player.y);
      if (rocketLevel >= 2) {
        rocket.damage *= 2;
      }
      rockets.push(rocket);
      playSound('rocket');
      // Don't return - continue to fire regular bullet
    }
    
    // Fire fire pulse as extra, not replacement
    if (isFire && fireLevel > 0) {
      const firePulse = new FirePulse(player.x, player.y, Math.atan2(aim.y, aim.x));
      fires.push(firePulse);
      playSound('fire');
      spawnParticles(player.x, player.y, 'rgba(255,100,0,0.9)', 20, Math.PI*2, 150);
    }

      if (isFlanker && flankerLevel > 0) {
    const baseBackwardAngle = Math.atan2(aim.y, aim.x) + Math.PI; // 180 degrees opposite
    
    if (flankerLevel === 7) {
      // Level 7: Fire 10 bullets in a full backward circle
      for (let i = 0; i < flankerBullets; i++) {
        const angle = baseBackwardAngle + (i / flankerBullets) * Math.PI * 2;
        const dx = Math.cos(angle);
        const dy = Math.sin(angle);
        
        const bullet = { 
          x: player.x + dx*player.r*1.6, 
          y: player.y + dy*player.r*1.6, 
          dx, dy, 
          t:0, 
          life: player.bulletLife * 0.8,
          speed: player.bulletSpeed * 0.9,
          size: player.bulletSize * 0.8,
          willExplode: false,
          damage: 0.8 * player.damageMultiplier,
          flanker: true,
          color: '#74c0fc'
        };
        
        bullets.push(bullet);
      }
    } else if (flankerLevel === 4) {
      // Level 4: Fire 4 bullets in a backward cross pattern
      const angles = [
        baseBackwardAngle, // Straight back
        baseBackwardAngle + Math.PI/4, // Back-left diagonal
        baseBackwardAngle - Math.PI/4, // Back-right diagonal
        baseBackwardAngle + Math.PI/2  // Perpendicular back
      ];
      for (let i = 0; i < Math.min(flankerBullets, angles.length); i++) {
        const dx = Math.cos(angles[i]);
        const dy = Math.sin(angles[i]);
        
        const bullet = { 
          x: player.x + dx*player.r*1.6, 
          y: player.y + dy*player.r*1.6, 
          dx, dy, 
          t:0, 
          life: player.bulletLife,
          speed: player.bulletSpeed,
          size: player.bulletSize,
          willExplode: false,
          damage: 1 * player.damageMultiplier,
          flanker: true,
          color: '#74c0fc'
        };
        
        bullets.push(bullet);
      }
    } else {
      // Levels 1-6: Fire backward bullets in a spread pattern
      for (let i = 0; i < flankerBullets; i++) {
        const spreadOffset = (i - Math.floor(flankerBullets / 2)) * flankerAngle;
        const bulletAngle = baseBackwardAngle + spreadOffset;
        const dx = Math.cos(bulletAngle);
        const dy = Math.sin(bulletAngle);
        
        const bullet = { 
          x: player.x + dx*player.r*1.6, 
          y: player.y + dy*player.r*1.6, 
          dx, dy, 
          t:0, 
          life: player.bulletLife * (flankerLevel >= 5 ? 1.2 : 1),
          speed: player.bulletSpeed * (flankerLevel >= 6 ? 1.1 : 1),
          size: player.bulletSize * (flankerLevel >= 5 ? 1.2 : 1),
          willExplode: false,
          damage: 1 * player.damageMultiplier * (flankerLevel >= 6 ? 1.2 : 1),
          flanker: true,
          color: '#74c0fc'
        };
        
        bullets.push(bullet);
      }
    }
  }
  
    const spread = player.spread * (1 + Math.min(1.5, (difficulty-1)/2));
    const angleOffset = rand(-spread/2, spread/2);
    const cos = Math.cos(angleOffset), sin = Math.sin(angleOffset);
    
    const dx = aim.x * cos - aim.y * sin;
    const dy = aim.x * sin + aim.y * cos;
    
    const bullet = { 
      x: player.x + dx*player.r*1.6, 
      y: player.y + dy*player.r*1.6, 
      dx, dy, 
      t:0, 
      life: player.bulletLife,
      speed: player.bulletSpeed,
      size: player.bulletSize,
      willExplode: false,
      damage: 1 * player.damageMultiplier,
      returning: false,
      initialX: player.x + dx*player.r*1.6,
      initialY: player.y + dy*player.r*1.6,
      // FIXED: For mythical heavy caliber - bullets don't break when hitting enemies
      persistent: player.stats.knockbackBullets.level >= 5,
      hitEnemies: [],
      // Power bullet can damage extra enemies before breaking
      maxHits: player.stats.powerBullet.level > 0 ? player.stats.powerBullet.level + 1 : 1
    };
    
    if (isPowerBullet) {
      bullet.damage *= powerBulletMultiplier;
      bullet.speed *= 0.5;
      bullet.powerBullet = true;
      bullet.color = '#ff6b6b';
      bullet.maxHits = player.stats.powerBullet.level + 2; // Extra hits for power bullets
    }
    
    if (player.stats.boomerang.level > 0) {
      const boomerangChance = player.stats.boomerang.level === 1 ? 0.2 : 
                             player.stats.boomerang.level === 2 ? 0.5 : 1.0;
      if (Math.random() < boomerangChance) {
        bullet.boomerang = true;
      }
    }
    
    bullets.push(bullet);
    
    const shouldFireShotgun = shotgunLevel > 0 && (bulletCounter % shotgunInterval === 0);
    if (shouldFireShotgun) {
      for (let i = 0; i < shotgunBullets; i++) {
        const spreadAngle = Math.PI / 12;
        const angleOffset = (i - (shotgunBullets - 1) / 2) * spreadAngle;
        const cos = Math.cos(angleOffset), sin = Math.sin(angleOffset);
        
        const dx = aim.x * cos - aim.y * sin;
        const dy = aim.x * sin + aim.y * cos;
        
        // shotgun bullets
        const shotgunBullet = { 
          x: player.x + dx*player.r*1.6, 
          y: player.y + dy*player.r*1.6, 
          dx, dy, 
          t:0, 
          life: player.bulletLife + 0.3,
          speed: player.bulletSpeed,
          size: player.bulletSize * 1,
          willExplode: false,
          damage: 1 * player.damageMultiplier,
          shotgun: true
        };
        
        bullets.push(shotgunBullet);
      }
      
      sfx(600, 0.1, 0.03, 'square');
    }
    
    sfx(1200 - Math.min(400, difficulty*60), 0.03, 0.01, 'sine');
    spawnParticles(player.x + aim.x*player.r, player.y + aim.y*player.r, 'rgba(200,255,200,0.9)', 5, Math.PI/2, 40);
    
    const recoilForce = 120 * player.knockback;
    player.vx -= aim.x * recoilForce;
    player.vy -= aim.y * recoilForce;
    
    bulletCounter++;
  }

  // paints (green blobs) bigger & stronger slow
  function makePaint(x,y){
    paints.push({ x, y, r: 42 + Math.min(32, difficulty*6), life: 2.0 });
    spawnParticles(x,y,'rgba(130,255,170,0.95)',18,Math.PI*2,60);
    sfx(720, 0.06, 0.012, 'sine');
  }

  // Check for level up
  function checkLevelUp(){
    if(playerXP >= xpToNextLevel && !maxLevelReached){
      playerLevel++;
      playerXP -= xpToNextLevel;
      xpToNextLevel = Math.floor(xpToNextLevel * 1.1);
      levelEl.textContent = playerLevel;
      
      pendingUpgrades++;
      
      // Check if player has reached max level
      let totalUpgrades = 0;
      let maxUpgrades = 0;
      for (const stat in player.stats) {
        totalUpgrades += player.stats[stat].level;
        maxUpgrades += player.stats[stat].max;
      }
      
      if (totalUpgrades >= maxUpgrades - 4) { // 4 final upgrades
        maxLevelReached = true;
        pendingUpgrades = 0;
        levelUpNotification.style.display = 'block';
        levelUpNotification.querySelector('.level-up-text').textContent = 'MAX LEVEL REACHED!';
        levelUpNotification.querySelector('.level-up-hint').textContent = 'No more upgrades available';
        setTimeout(() => {
          levelUpNotification.style.display = 'none';
        }, 3000);
        return;
      }
      
      // FIXED: Only show notification, don't auto-open upgrade menu
      if (running && !gamePaused) {
        levelUpNotification.style.display = 'block';
        
        // Add upgrade pulse effect
        createUpgradePulse();
        
        // Add screen flash for upgrade
        createScreenFlash('rgb(0, 119, 68,0.1)', 0.5);
        
        // Add upgrade notification particles
        spawnParticles(player.x, player.y, 'rgba(126,231,135,0.9)', 30, Math.PI*2, 100);
        
        setTimeout(() => {
          levelUpNotification.style.display = 'none';
        }, 1500);
      }
    }
  }

// Show upgrade selection - FIXED: Always provides 3 options
function showUpgradeMenu() {
  if (pendingUpgrades <= 0 || maxLevelReached) return;

  upgradeMenu.style.display = 'block';
  upgradeOptions.innerHTML = '';

  const totalChance = commonChance + rareChance + legendaryChance + mythicalChance;

  const selectedUpgrades = [];
  let attempts = 0;
  const maxAttempts = 50;

  // Get ALL available upgrades (not filtered by rarity first)
  const allAvailableUpgrades = [];
  const upgradesToRemove = ['autodash'];
  
  for (const stat in player.stats) {
    // Skip shield regen if shield is level 0
    if (stat === 'shieldRegen' && player.stats.shield.level === 0) continue;
    
    // In hardcore mode, skip blocked upgrades
    if (gameMode === 'hardcore' &&
      (stat === 'extraLife' || stat === 'shield' || stat === 'health' || stat === 'holyLife')) {
      continue;
    }
    
    // Skip removed upgrades
    if (upgradesToRemove.includes(stat)) continue;
    
    // Emergency ability upgrade checks
    const isEmergencyAbility = [
      'shockwave', 'guards', 'freeze',
      'lastResort', 'saferSpaces', 'minecount'
    ].includes(stat);

    // Also exclude mineCount from appearing as an upgrade if we don't have mineLayer
    if (stat === 'mineCount' && emergencyAbility !== 'mineLayer') {
      continue;
    }

    if (isEmergencyAbility) {
      const currentPower = abilityPowerLevels[emergencyAbility] || 0;
      const newAbilityPower = abilityPowerLevels[stat] || 0;

      // Skip if new ability is weaker than or equal to current (unless it's the same one for leveling up)
      if (newAbilityPower <= currentPower && stat !== emergencyAbility) {
        continue;
      }

      // Skip if this ability type is already selected (except for re-picking the same)
      if (selectedAbilities.has(stat) && stat !== emergencyAbility) {
        continue;
      }
    }

    // Check if upgrade is not maxed
    if (player.stats[stat].level < player.stats[stat].max) {
      allAvailableUpgrades.push(stat);
    }
  }

  // First, try to get 3 upgrades using rarity system (like before)
  while (selectedUpgrades.length < 3 && attempts < maxAttempts) {
    attempts++;

    // Determine rarity based on chances
    const randVal = Math.random() * totalChance;
    let rarity;

    if (randVal < commonChance) {
      rarity = 'common';
    } else if (randVal < commonChance + rareChance) {
      rarity = 'rare';
    } else if (randVal < commonChance + rareChance + legendaryChance) {
      rarity = 'legendary';
    } else {
      rarity = 'mythical';
    }

    // Get available upgrades for this rarity
    const availableUpgrades = allAvailableUpgrades.filter(stat =>
      player.stats[stat].rarity === rarity && !selectedUpgrades.includes(stat)
    );

    // If no upgrades available for this rarity, try next rarity
    if (availableUpgrades.length === 0) {
      continue;
    }

    // Select a random upgrade from available ones
    const type = availableUpgrades[Math.floor(Math.random() * availableUpgrades.length)];
    selectedUpgrades.push(type);
  }

  // ===== FIX: If we still don't have enough upgrades, fill with ANY available upgrades =====
  if (selectedUpgrades.length < 3) {
    const remainingUpgrades = allAvailableUpgrades.filter(stat =>
      !selectedUpgrades.includes(stat)
    );

    // Add unique fallback upgrades until we have 3 or run out
    for (const upgrade of remainingUpgrades) {
      if (selectedUpgrades.length >= 3) break;
      selectedUpgrades.push(upgrade);
    }
  }

  // ===== FIX: If STILL not enough upgrades (all upgrades maxed), offer special bonuses =====
  if (selectedUpgrades.length < 3) {
    // Player has maxed most upgrades - offer special bonus upgrades
    const bonusUpgrades = ['extraLife', 'health', 'shield', 'damage'];
    
    for (let i = selectedUpgrades.length; i < 3; i++) {
      // Create a special "bonus" upgrade that gives stats even when maxed
      const bonusType = bonusUpgrades[i % bonusUpgrades.length];
      selectedUpgrades.push(bonusType);
    }
  }

  

  // Store the selected upgrades to prevent them from changing
  window.currentUpgradeOptions = selectedUpgrades;

  // Create upgrade options
  selectedUpgrades.forEach(type => {
    const isMaxed = player.stats[type].level >= player.stats[type].max;
    const rarity = player.stats[type].rarity;
    const option = document.createElement('div');
    option.className = `upgrade-option ${isMaxed ? 'maxed' : ''} rarity-${rarity}`;
    
    // Special handling for bonus upgrades when everything is maxed
    let levelText = '';
    let description = '';
    
    if (isMaxed && player.stats[type].level >= player.stats[type].max) {
      // This is a bonus upgrade beyond max level
      levelText = 'MAX+';
      description = getBonusUpgradeDescription(type);
    } else {
      levelText = `${player.stats[type].level}/${player.stats[type].max}`;
      description = getUpgradeDescription(type);
    }
    
    option.innerHTML = `
      <div class="upgrade-title">${getUpgradeTitle(type)} 
        <span>${levelText} <span class="upgrade-rarity rarity-${rarity}">${rarity.toUpperCase()}</span></span>
      </div>
      <div class="upgrade-desc">${description}</div>
    `;

    if (!isMaxed) {
      option.addEventListener('click', () => selectUpgrade(type));
    } else if (player.stats[type].level >= player.stats[type].max) {
      // Allow clicking on maxed bonus upgrades for special rewards
      option.addEventListener('click', () => selectBonusUpgrade(type));
    }

    upgradeOptions.appendChild(option);
  });

  // Update refresh button state
  if (refreshUsed) {
    refreshUpgrades.disabled = true;
    refreshUpgrades.textContent = 'REFRESH (0/1)';
  } else {
    refreshUpgrades.disabled = false;
    refreshUpgrades.textContent = 'REFRESH (1/1)';
  }
}

// Add this helper function for bonus upgrade descriptions
function getBonusUpgradeDescription(type) {
  const bonusDescs = {
    extraLife: 'Bonus: Gain +2 additional lives (beyond max)',
    health: 'Bonus: +1 life (beyond max)',
    shield: 'Bonus: +1 shield point (beyond max)',
    damage: 'Bonus: +10% bullet damage (beyond max)'
  };
  return bonusDescs[type] || 'Special bonus upgrade';
}

// Add this function to handle bonus upgrades
function selectBonusUpgrade(type) {
  upgradesGathered++;
  
  // Apply bonus effects beyond max level
  switch (type) {
    case 'extraLife':
      player.lives += 2;
      livesEl.textContent = player.lives;
      break;
    case 'health':
      player.lives += 1;
      livesEl.textContent = player.lives;
      break;
    case 'shield':
      shield = Math.min(10, (shield || 0) + 1);
      break;
    case 'damage':
      player.damageMultiplier *= 1.1;
      break;
  }
  
  // Visual effects
  upgradeInvulTimer = 1.3;
  spawnParticles(player.x, player.y, 'rgba(255,215,0,0.9)', 25, Math.PI * 2, 100);
  sfx(1000, 0.1, 0.03, 'sine');
  
  // Close upgrade menu
  pendingUpgrades--;
  if (pendingUpgrades > 0 && !maxLevelReached) {
    showUpgradeMenu();
  } else {
    upgradeMenu.style.display = 'none';
    gamePaused = false;
  }
}

  function getUpgradeTitle(type){
    const titles = {
      fireRate: 'Rapid Fire',
      bulletSpeed: 'Hyper Velocity',
      movement: 'Agility Boost',
      knockback: 'Recoil Dampener',
      bulletSize: 'Heavy Caliber',
      bulletLife: 'Extended Range',
      xpBoost: 'XP Magnet',
      extraLife: 'Extra Life',
      workers: 'Mini Bot',
      ghost: 'Ghost Summoner',
      holyLife: 'Holy Life',
      killBoost: 'Kill Boost',
      boomerang: 'Boomerang',
      fire: 'Fire Pulse',
      shotgun: 'Shotgun',
      shield: 'Shield',
      shieldRegen: 'Shield Regen',
      health: 'Health',
      damage: 'Damage Boost',
      sprint: 'Sprint',
      rocket: 'Heat Seeking Rocket',
      powerBullet: 'Power Bullet',
      knockbackBullets: 'Knockback Bullets',
      workerCollector: 'Worker Collector',
      flanker: 'Flanker',
      shockwave: 'Shockwave',
      guards: 'Guards',
      freeze: 'Freeze',
      lastResort: 'Last Resort',
      music: 'Battle Nerve',
      damageZone: 'Damage Zone',
      minigun: 'Minigun',
      saferSpaces: 'Safer Spaces',
      mineLayer: 'Mine Layer',
      mineCount: 'Mine Capacity',
      cooldownRefresh: ' Dangerous situations',
      reflectiveMirror: 'Mirror Shield',
      lightningStrike: 'Lightning Strike'
    };
    return titles[type];
  }

  function getUpgradeDescription(type){
    const descs = {
      fireRate: 'Increase fire rate by 20%',
      bulletSpeed: 'Bullets travel 30% faster',
      mineLayer: 'Deploy 3 mines that explode when touched (3 damage each)',
      movement: 'Movement speed increased by 15%',
      knockback: 'Remove recoil',
      bulletSize: player.stats.bulletSize.level === 0 ? 'Increase bullet size by 100%' :
                 player.stats.bulletSize.level === 1 ? 'Increase bullet size by 50% (total 150%)' : 'Increase bullet size by 50% (total 200%)',
      bulletLife: player.stats.bulletLife.level === 0 ? 'Increase bullet lifetime by 50%' :
                 player.stats.bulletLife.level === 1 ? 'Increase bullet lifetime by 50% (total 200%)' : 'Increase bullet lifetime by 30% (total 100%)',
      xpBoost: player.stats.xpBoost.level === 0 ? 'Increase XP from orbs from 30 to 50 (+20 XP)' :
              player.stats.xpBoost.level === 1 ? '+50% XP bonus (50 â†’ 75 XP per orb)' :
              player.stats.xpBoost.level === 2 ? '50% chance for XP orb to spawn when enemy dies' :
              player.stats.xpBoost.level === 3 ? 'Pull all close XP orbs toward the player (only works on xp orbs dropped from enemies)' :
                                                '+50% bonus to all XP received',
      extraLife: 'Gain +4 additional lives',
      workers: player.stats.workers.level === 0 ? 'Get 2 mini bots that attacks enemies' :
              player.stats.workers.level === 1 ? 'Adds 2 more mini bots' :
              player.stats.workers.level === 2 ? 'Add 2 more mini bots' : 'Add 4 mini bots',
      ghost: player.stats.ghost.level === 0 ? '25% chance to summon ghost on kill' :
            player.stats.ghost.level === 1 ? '40% Chance to summon a ghost on kill | +20% ghost speed & +100% ghost damage' : '50% Chance to summon a ghost on kill | +6.7% ghost speed & +50% ghost damage',
      holyLife: 'Tripple your current lives',
      killBoost: player.stats.killBoost.level === 0 ? '+40% speed for 3s after kill' :
                player.stats.killBoost.level === 1 ? '+50% speed for 4s after kill' : '+60% speed for 5s after kill',
      boomerang: player.stats.boomerang.level === 0 ? '20% chance for bullets to return' :
                player.stats.boomerang.level === 1 ? '50% chance for bullets to return' : '100% chance for bullets to return',
      fire: player.stats.fire.level === 0 ? 'Every other bullet becomes a fire pulse' : 'Fire area +50% and duration +50%',
      shotgun: player.stats.shotgun.level === 0 ? 'Every third bullet fires 2 extra bullets' :
              player.stats.shotgun.level === 1 ? 'Every other bullet fires 2 extra bullets' :
              player.stats.shotgun.level === 2 ? 'Every other bullet fires 4 extra bullets' :
              player.stats.shotgun.level === 3 ? 'Every bullet fires 4 extra bullets' : 'Every bullet fires 8 extra bullets',
      shield: player.stats.shield.level === 0 ? 'Gain 3 shield points that block damage' :
              player.stats.shield.level === 1 ? 'Increase maximum shield to 5 points' : 
              'Increase maximum shield to 6 points',
      shieldRegen: player.stats.shieldRegen.level === 0 ? 'Shield regenerates after 6 seconds without taking damage' :
                  player.stats.shieldRegen.level === 1 ? 'Shield regenerates 1 point every 4 seconds when not taking damage' : 
                  'Passive shield regeneration: 0.1 points per second (1 point every 10s)',      
      health: player.stats.health.level === 0 ? '+2 lives' : ' +1 life',
      damage: player.stats.damage.level < 2 ? 'Increase bullet damage by 25%' :
             player.stats.damage.level < 3 ? 'Increase bullet damage by 30%' :
             player.stats.damage.level < 4 ? 'Increase bullet damage by 40%' : 'Increase bullet damage by 50%',
      sprint: player.stats.sprint.level === 0 ? 'Move 50% faster when not shooting + Heal 1 HP every 15 seconds (10 HP cap)' :
              player.stats.sprint.level === 1 ? 'Move 75% faster when not shooting + Heal 1 HP every 10 seconds (10 HP cap)' : 
              'Move 100% faster + Heal 1 HP every 8 seconds (100 HP cap)',      
      rocket: player.stats.rocket.level === 0 ? '50% chance for every bullet to fire a rocket' : '100% chance & increased DoT',
      powerBullet: player.stats.powerBullet.level === 0 ? 'Every 4th bullet deals double damage (half speed/range)' :
                  player.stats.powerBullet.level === 1 ? 'Every 3rd bullet deals triple damage' : 'Every 2nd bullet deals quadruple damage',
      knockbackBullets: player.stats.knockbackBullets.level === 0 ? 'Bullets push enemies back' :
                      player.stats.knockbackBullets.level === 1 ? 'Bullets push enemies back a greater distance' : 
                      player.stats.knockbackBullets.level === 2 ? 'Bullets push all enemies hit in a small area back a distance' :
                      player.stats.knockbackBullets.level === 3 ? ' bullets push all enemies hit in a small area back a greater distance' :
                      'Bullets no longer break when hitting enemies but can only damage each enemy once',
      workerCollector: player.stats.workerCollector.level === 0 ? 'Adds a worker to the map that runs around collecting xp orbs for the player' :
                      player.stats.workerCollector.level === 1 ? 'Workers gain an additional 100% xp from xp orbs and move 100% faster' :
                      player.stats.workerCollector.level === 2 ? 'Workers leave a fire trail dealing burning damage to enemies' :
                      'Workers are equipped with auto-aim weapon that fires 2 bullets every second',
      flanker: player.stats.flanker.level === 0 ? 'Every second bullet fires 2 bullets backwards (15Â° spread)' :
          player.stats.flanker.level === 1 ? 'Every second bullet fires 4 bullets backwards (+2 bullets) (20Â° spread)' :
          player.stats.flanker.level === 2 ? 'Every bullet fires 4 bullets backwards (22.5Â° spread)' :
          player.stats.flanker.level === 3 ? 'Every bullet fires 6 bullets backwards (+2 bullets) in cross pattern' :
          player.stats.flanker.level === 4 ? 'Every bullet fires 7 bullets backwards (+1 bullet) (60Â° spread)' :
          player.stats.flanker.level === 5 ? 'Every bullet fires 8 bullets backwards (+1 bullet) (72Â° spread)' :
          'Every bullet fires 10 bullets backwards in full circle (+2 bullets)',
        shockwave: 'Replace emergency ability with Shockwave: Fire an electrical shockwave every 4 seconds that expands and freezes enemies',
        guards: 'Replace emergency ability with Guards: Summon 2 guards for every boss youve killed + 3',
        freeze: 'Replace emergency ability with Freeze: Freeze all enemies for 10 seconds',
        lastResort: player.stats.lastResort.level === 0 ? 'Replace emergency ability with Last Resort: Become invincible and move 50% faster for 3 seconds' :
                  'Last Resort now has shorter cooldown',
        music: 'Increase all stats by 20% while FIRE music is playing (stats include: fire rate, damage, bullet speed, bullet length, bullet size, movement speed and lives)',
        damageZone: player.stats.damageZone.level === 0 ? 'Passive: Creates a damage zone around you that continuously damages enemies (NOTE! NO XP recived from damage-zone kills)' :
                  'Damage zone +30% increased damage and +50% larger area',
        minigun: player.stats.minigun.level === 0 ? 'Fire an additional tiny bullet every 0.4 seconds' :
                player.stats.minigun.level === 1 ? 'Now fires every 0.25 seconds' :
                player.stats.minigun.level === 2 ? 'Now fires every 0.15 seconds' :
                player.stats.minigun.level === 3 ? 'Now fires every 0.1 seconds' : 'Now fires every 0.05 seconds',
        saferSpaces: 'Replace emergency ability with Safer Spaces: Build a protective box around player for 10 seconds (8 HP)',
        mineCount: player.stats.mineCount.level === 0 ? 'Increase mine count to 5, mines deal double damage and last 1 second longer' :
            player.stats.mineCount.level === 1 ? 'Increase mine count to 7, mines deal 50% more damage and last 1 second longer' : 'Increase mine count to 9, mines deal 30% more damage and last 1 second longer (8seconds)',
        cooldownRefresh: 'Refresh emergency ability cooldown when taking damage',
        reflectiveMirror: player.stats.reflectiveMirror.level === 0 ? '30% chance to reflect enemy bullets' :
                 player.stats.reflectiveMirror.level === 1 ? '+20% chance to reflect enemy bullets(50%)' : '+10% chance to reflect enemy bullets(60%)',
        lightningStrike: 'Fire a lightning that chains through several enemies'

    };
    return descs[type];
  }

  function selectUpgrade(type){
    upgradesGathered++;
    
    player.stats[type].level++;

    upgradeInvulTimer = 1.3; // 1.3 seconds of invulnerability after upgrade
    
    const legendaryBonus = player.stats[type].rarity === 'legendary' ? 1.2 : 1.0;
    const mythicalBonus = player.stats[type].rarity === 'mythical' ? 1.3 : 1.0;
    
    switch(type){
      case 'fireRate':
        player.fireRate = Math.max(0.05, player.fireRate * 0.8 * (1/legendaryBonus));
        break;
      case 'bulletSpeed':
        player.bulletSpeed *= 1.3 * legendaryBonus;
        break;
      case 'movement':
        player.speed *= 1.20 * legendaryBonus;
        break;
      case 'knockback':
        player.knockback = 0;
        break;
      case 'bulletSize':
        if (player.stats.bulletSize.level === 1) player.bulletSize *= 2 * legendaryBonus;
        else player.bulletSize *= 1.5 * legendaryBonus;
        break;
      case 'bulletLife':
        if (player.stats.bulletLife.level === 1) player.bulletLife *= 1.6 * legendaryBonus;
        else player.bulletLife *= 1.4 * legendaryBonus;
        break;
      case 'xpBoost':
        break;
      case 'extraLife':
        player.lives += Math.floor(4 * legendaryBonus);
        livesEl.textContent = player.lives;
        break;
      case 'workers':
        player.maxWorkers = [0, 2, 4, 6, 10][player.stats.workers.level];
        while (player.workers.length < player.maxWorkers) {
          player.workers.push(new Worker());
        }
        break;
      case 'ghost':
        break;
      case 'holyLife':
        // Boosted: Holy life now gives more lives
        player.lives = Math.floor(player.lives * 2.5 * legendaryBonus);
        livesEl.textContent = player.lives;
        break;
      case 'killBoost':
        break;
      case 'boomerang':
        break;
      case 'fire':
        break;
      case 'shotgun':
        break;
      case 'shield':
        shield = player.stats.shield.level === 1 ? Math.floor(3 * legendaryBonus) : 
                player.stats.shield.level === 2 ? Math.floor(5 * legendaryBonus) : Math.floor(6 * legendaryBonus);
        break;
      case 'shieldRegen':
        break;
      case 'health':
        player.lives += player.stats.health.level === 1 ? Math.floor(2 * legendaryBonus) : Math.floor(1 * legendaryBonus);
        livesEl.textContent = player.lives;
        break;
      case 'damage':
        if (player.stats.damage.level < 2) {
          player.damageMultiplier *= 1.25 * legendaryBonus;
        } else if (player.stats.damage.level < 3) {
          player.damageMultiplier *= 1.3 * legendaryBonus;
        } else if (player.stats.damage.level < 4) {
          player.damageMultiplier *= 1.4 * legendaryBonus;
        } else {
          player.damageMultiplier *= 1.5 * legendaryBonus;
        }
        break;
      case 'sprint':
        break;
      case 'rocket':
        // Boosted: Rockets are now stronger
        if (player.stats.rocket.level === 1) {
          player.damageMultiplier *= 1;
        } else if (player.stats.rocket.level === 2) {
          player.damageMultiplier *= 1.2;
        }
        break;
      case 'powerBullet':
        break;
      case 'knockbackBullets':
        // Remove rare knockback bullets if mythical is picked
        if (player.stats.knockbackBullets.level >= 4) {
          player.stats.knockbackBullets.rarity = 'mythical';
        }
        break;
      case 'workerCollector':
        if (player.stats.workerCollector.level === 1) {
          const worker = new WorkerCollector();
          player.workers.push(worker);
        } else if (player.stats.workerCollector.level === 2) {
          for (const worker of player.workers) {
            if (worker instanceof WorkerCollector) {
              worker.xpMultiplier = 1.5;
              worker.speed *= 1.5;
            }
          }
        } else if (player.stats.workerCollector.level === 3) {
          // Fire trail is handled in the WorkerCollector class
        } else if (player.stats.workerCollector.level === 4) {
          // Auto-aim weapon is handled in the WorkerCollector class
        }
        break;
      case 'flanker':
        break;
      case 'shockwave':
        emergencyAbility = 'shockwave';
        selectedAbilities.add('shockwave');
        break;
      case 'guards':
        emergencyAbility = 'guards';
        selectedAbilities.add('guards');
        break;
      case 'freeze':
        emergencyAbility = 'freeze';
        selectedAbilities.add('freeze');
        break;
      case 'lastResort':
        emergencyAbility = 'lastResort';
        selectedAbilities.add('lastResort');
        break;
      case 'saferSpaces':
        emergencyAbility = 'saferSpaces';
        selectedAbilities.add('saferSpaces');
        break;
      case 'music':
        playAdamMusic();
        player.fireRate = Math.max(0.2, player.fireRate * 0.8); 
        player.bulletDamage = (player.bulletDamage * 1.2);
        player.bulletSize = (player.bulletSize * 1.2);
        player.bulletSpeed = (player.bulletSpeed * 1.2);
        player.bulletLife = (player.bulletLife * 1.2);
        player.speed = (player.speed * 1.2);
        player.lives = (player.lives + 2);
        break;
      case 'damageZone':
        damageZoneActive = true;
        // Level 2 increases damage and area
        if (player.stats.damageZone.level === 2) {
          player.damageZoneMultiplier = 1.3;
          player.damageZoneArea = 1.5;
        }
        break;
      case 'minigun':
        minigunActive = true;
        break;
      case 'saferSpaces':
        emergencyAbility = 'saferSpaces';
        break;
      case 'mineCount':
        break;
      case 'cooldownRefresh':
        break;
      case 'reflectiveMirror':
        reflectiveMirrorActive = true;
        reflectiveMirrorRadius = 55;
        
        // Update chance based on level
        switch(player.stats.reflectiveMirror.level) {
          case 1:
            reflectiveMirrorChance = 0.30; // 30%
            break;
          case 2:
            reflectiveMirrorChance = 0.50; // 50%
            break;
          case 3:
            reflectiveMirrorChance = 0.60; // 60%
            break;
        }
        break;
      case 'lightningStrike':
        break;
      }
    
    pendingUpgrades--;
    
    if (pendingUpgrades > 0 && !maxLevelReached) {
      showUpgradeMenu();
    } else {
      upgradeMenu.style.display = 'none';
      gamePaused = false;
    }
    
    spawnParticles(player.x, player.y, 'rgba(126,231,135,0.9)', 25, Math.PI*2, 100);
    sfx(800, 0.1, 0.03, 'sine');
  }

  // Spawn random upgrade
  function spawnUpgrade(){
    // Don't spawn upgrades if game hasn't started
    if (!gameStarted || !running) return;
    
    if(upgrades.length < 2 && Math.random() < 0.015){
      const availableTypes = [];
      for (const stat in player.stats) {
        if (stat === 'shieldRegen' && player.stats.shield.level === 0) {
          continue;
        }
        
        // In hardcore mode, skip extra life and shield upgrades
        if (gameMode === 'hardcore' && 
            (stat === 'extraLife' || stat === 'shield' || stat === 'health' || stat === 'holyLife')) {
          continue;
        }
        
        if (player.stats[stat].level < player.stats[stat].max) {
          availableTypes.push(stat);
        }
      }
      
      if (availableTypes.length > 0) {
        const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        upgrades.push(new Upgrade(type));
      }
    }
  }
  // Check for boss spawn
  function checkBossSpawn(dt) {
  if (endlessMode) {
    bossSpawnTimer += dt;
    if (bossSpawnTimer > 20 + Math.random() * 10) {
      bossSpawnTimer = 0;
      spawnRandomBoss();
    }
    return;
  }
  
  // Check schedule for boss spawns
  for (let i = 0; i < bossSpawnSchedule.length; i++) {
    const bossSchedule = bossSpawnSchedule[i];
    
    // Skip if already spawned and killed
    if (bossSchedule.killed) continue;
    
    // Check if it's time to spawn
    if (timeAlive >= bossSchedule.time && !bossSchedule.spawned) {
      bossSchedule.spawned = true;
      spawnScheduledBoss(bossSchedule.type);
    }
  }
  
  // Check if all scheduled bosses are dead and activate endless mode
  if (!endlessMode) {
    const allBossesDead = bossSpawnSchedule.every(boss => boss.killed);
    if (allBossesDead) {
      endlessMode = true;
      levelUpNotification.style.display = 'block';
      levelUpNotification.querySelector('.level-up-text').textContent = 'ENDLESS MODE!';
      levelUpNotification.querySelector('.level-up-hint').textContent = 'Survive as long as you can!';
      setTimeout(() => {
        levelUpNotification.style.display = 'none';
      }, 3000);
    }
  }
}

function spawnScheduledBoss(type) {
  let boss;
  
  switch(type) {
    case 'easy':
      boss = new EasyBoss();
      break;
    case 'medium':
      boss = new MediumBoss();
      break;
    case 'hard':
      boss = new HardBoss();
      break;
    case 'final':
      boss = new FinalBoss();
      break;
    case 'creeper':
      boss = new MegaCreeperBoss();
      break;
  }
  
  if (boss) {
    echoes.push(boss);
    activeBosses.push(boss);
    
    // Add health bar for this boss
    bossHealthBars.push({
      boss: boss,
      yOffset: (bossHealthBars.length * 30) + 20 // Stack health bars
    });
  }
}

  // Spawn random boss for endless mode
    function spawnRandomBoss() {
    // Don't spawn if there are already 3 active bosses
    if (activeBosses.length >= 3) return;
    
    const bossTypes = ['easy', 'medium', 'hard', 'final', 'creeper'];
    const randomType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
    spawnScheduledBoss(randomType);
  }

  // FIXED: Shield regen - turns off when player takes damage
  function updateShield(dt) {
    if (player.stats.shield.level === 0) return;

    // In the update function, add this:
    if (shieldDamageCooldown > 0) {
      shieldDamageCooldown -= dt;
    }
    
    if (shieldDamageCooldown > 0) {
      shieldDamageCooldown -= dt;
    }
    
    const maxShield = player.stats.shield.level === 1 ? 3 : 
                     player.stats.shield.level === 2 ? 5 : 6;
    
    if (shield >= maxShield) {
      shieldTimer = 0;
      return;
    }
    
    // FIX: Reset shield timer when player takes damage
    if (player.invul > 0) {
      shieldTimer = 0;
      return;
    }
    
    shieldTimer += dt;
    
    const regenLevel = player.stats.shieldRegen.level;
    let regenDelay = 12;
    let regenRate = 0.1; 
    let passiveRegen = 0.05; 
    
    if (regenLevel >= 1) regenDelay = 6;
    if (regenLevel >= 2) regenRate = 0.2; 
    if (regenLevel >= 3) passiveRegen = 0.1;
    
    // FIX: Passive regen is always on
    if (passiveRegen > 0) {
      shield = Math.min(maxShield, shield + passiveRegen * dt);
    }
    
    // Active regen only when not taking damage
    if (shieldTimer >= regenDelay) {
      shield = Math.min(maxShield, shield + regenRate * dt);
    }
  }

  // update loop
  function step(dt){
    if(!running || !gameStarted || gamePaused) return;
    
    // In freemode, stop scoring but keep playing
    if (gameMode === 'freemode' && player.lives <= 0) {
      // Player can keep playing but score doesn't increase
    } else {
      timeAlive += dt; 
      score = Math.floor(timeAlive*10);
    }
    
    if (upgradeSelectionCooldown > 0) {
      upgradeSelectionCooldown -= dt;
    }
    
    if (killBoostTimer > 0) {
      killBoostTimer -= dt;
    }
    
    updateUpgradeChances(dt);
    updateEmergencyAbilities(dt);
    updateMinigunBullets(dt);

    if (reflectiveMirrorActive) {
    reflectiveMirrorPulse += dt;
    }

    // Update lightning strikes
    for (let i = lightningStrikes.length - 1; i >= 0; i--) {
      if (!lightningStrikes[i].update(dt)) {
        lightningStrikes.splice(i, 1);
      }
    }
    
    updateShield(dt);
    updateSprint(dt);
    updateUI();
    
    // In hardcore mode, bosses have 100% more health and fire 25% more bullets
    const bossMultiplier = gameMode === 'hardcore' ? 2 : 1.0;
    difficulty = 1 + timeAlive*0.06 * (endlessMode ? 2 : 1) * bossMultiplier;
    diffEl.textContent = difficulty < 2 ? 'Normal' : difficulty < 4 ? 'Hot' : difficulty < 6 ? 'Chaotic' : 'Insane';

    const baseSpeed = player.speed;
    const killBoostMultiplier = killBoostTimer > 0 ? 
                               (player.stats.killBoost.level === 1 ? 1.4 :
                                player.stats.killBoost.level === 2 ? 1.5 : 
                                player.stats.killBoost.level === 4 ? 3.0 : 1.6) : 1;
    const effectiveSpeed = baseSpeed * killBoostMultiplier;

    let ax = 0, ay = 0;
    if (input.left) ax -= 1; if (input.right) ax += 1; if (input.up) ay -= 1; if (input.down) ay += 1;
    
    if (ax !== 0 && ay !== 0) {
      ax *= 0.7071;
      ay *= 0.7071;
    }
    
    if (!ax && !ay && input.mouseDown) {
      const a = vecTo(player.x, player.y, input.mx, input.my);
      ax = a.x * 0.45; ay = a.y * 0.45;
    }
    
    player.vx = (player.vx*6 + ax*effectiveSpeed)/7; 
    player.vy = (player.vy*6 + ay*effectiveSpeed)/7;
    player.x += player.vx * dt; 
    player.y += player.vy * dt;
    player.x = clamp(player.x, player.r, W - player.r); 
    player.y = clamp(player.y, player.r, H - player.r);
    

    player.trail.push({x: player.x, y: player.y});
    if(player.trail.length > player.maxTrail){
      player.trail.shift();
    }

    fireTimer += dt;
    if (!player.autoFireToggle && (input.mouseClicked || (input.mouseDown && fireTimer >= player.fireRate)) && fireTimer >= 1) {
      fireTimer = 0;
      fireShot();
    }
    input.mouseClicked = false;
    
    if (player.autoFireToggle) {
      autoFireTimer += dt;
      if (autoFireTimer >= player.fireRate) {
        autoFireTimer = 0;
        fireShot();
      }
    }

    for (let i = spawnIndicators.length - 1; i >= 0; i--) {
      if (!spawnIndicators[i].update(dt)) {
        spawnIndicators.splice(i, 1);
      }
    }

    for (const worker of player.workers) {
      if (worker instanceof WorkerCollector) {
        worker.update(dt);
      } else {
        worker.update(dt, player.x, player.y);
      }
    }

    for (let i = ghosts.length - 1; i >= 0; i--) {
      if (!ghosts[i].update(dt)) {
        ghosts.splice(i, 1);
      }
    }

    for (let i = rockets.length - 1; i >= 0; i--) {
      if (!rockets[i].update(dt)) {
        rockets.splice(i, 1);
      }
    }

    for (let i = fires.length - 1; i >= 0; i--) {
      if (!fires[i].update(dt)) {
        fires.splice(i, 1);
      }
    }

    for (let i = bullets.length - 1; i >= 0; i--){
      const b = bullets[i];
b.t += dt;

      // FIXED: For mythical heavy caliber - bullets don't break when hitting enemies
      if (b.persistent && b.t > 1.0) {
        // After 1 second, the bullet can break
        if ((b.x < -50 || b.x > W+50 || b.y < -50 || b.y > H+50 || b.t >= b.life) && !b.returning) {
          if (b.willExplode && !b.enemy) {
          } else if (!b.enemy) {
            makePaint(b.x, b.y);
          }
          bullets.splice(i,1);
          continue;
        }
      } else if (!b.persistent) {
        // Normal bullet behavior
        if ((b.x < -50 || b.x > W+50 || b.y < -50 || b.y > H+50 || b.t >= b.life) && !b.returning) {
          if (b.willExplode && !b.enemy) {
          } else if (!b.enemy) {
            makePaint(b.x, b.y);
          }
          bullets.splice(i,1);
          continue;
        }
      }

      if (b.boomerang && b.t > b.life * 0.7) {
        b.returning = true;
        const toPlayer = vecTo(b.x, b.y, player.x, player.y);
        b.dx = toPlayer.x;
        b.dy = toPlayer.y;
        
        // Initialize boomerang hit timer
        if (b.boomerangLastHit === undefined) {
          b.boomerangLastHit = -Infinity;
        }
      }

      b.x += b.dx * b.speed * dt; 
      b.y += b.dy * b.speed * dt;

      if (b.returning) {
        const d = Math.hypot(b.x - player.x, b.y - player.y);
        if (d < player.r + b.size) {
          bullets.splice(i,1);
          continue;
        }
      }

      if (Math.random() < 0.2) {
        const trailColor = b.color || (b.shotgun ? 'rgba(255,200,100,0.8)' : 
                              (b.powerBullet ? 'rgba(255,100,100,0.8)' : 'rgba(255,255,255,0.8)'));
        particles.push({
          x:b.x, y:b.y, 
          vx: (Math.random()-0.5)*20, 
          vy:(Math.random()-0.5)*20, 
          life:0.25, 
          col: trailColor, 
          r:1.8
        });
      }
      
      if (!b.enemy) {
        for (let j = echoes.length - 1; j >= 0; j--){
          const e = echoes[j];
          
          // FIXED: For mythical heavy caliber - bullets can only damage each enemy once
          if (b.persistent && b.hitEnemies.includes(e)) {
            continue;
          }
          
          // FIXED: Power bullets can damage extra enemies before breaking
          if (b.powerBullet && b.hitEnemies.length >= b.maxHits) {
            bullets.splice(i,1);
            break;
          }
          
    const d = Math.hypot(b.x - e.x, b.y - e.y);
    if (d < e.r + b.size){
if (b.boomerang && b.returning) {
  // Initialize hit tracking if not already done
  if (!b.hitEnemies) {
    b.hitEnemies = [];
  }
  
  // Check if we've already hit this enemy
  if (b.hitEnemies.includes(e)) {
    continue; // Skip - already damaged this enemy
  }
  
  // Check hit cooldown for this specific bullet
  if (!b.boomerangLastHit || b.t - b.boomerangLastHit > 0.3) {
    b.boomerangLastHit = b.t;
    
    // Mark this enemy as hit by this bullet
    b.hitEnemies.push(e);
    
    const xpMultiplier = 1 + (player.stats.xpBoost.level > 0 ? 0.5 : 0) + 
                       (player.stats.xpBoost.level > 1 ? 0.2 : 0) +
                       (player.stats.xpBoost.level > 2 ? 0.3 : 0) +
                       (player.stats.xpBoost.level > 3 ? 0.2 : 0) +
                       (player.stats.xpBoost.level > 4 ? 0.1 : 0);
    
    if (e.takeDamage(b.damage)) {
      if (gameMode !== 'freemode' || player.lives > 0) {
        score += 8;
      }
      echoesKilled++;
      
      let xpAmount = 15;
      let xpMultiplier = 1;
      
      // Level 4: Increase all XP received by 50%
      if (player.stats.xpBoost.level === 4) {
        xpMultiplier = 1.5;
      }
      
      playerXP += xpAmount * xpMultiplier;

      // Level 4: 50% chance for XP orb to spawn when enemy dies
      const xpDropChance = player.stats.xpBoost.level === 4 ? 0.5 : 0;
      
      if (xpDropChance > 0 && Math.random() < xpDropChance) {
        upgrades.push(new Upgrade('xpBoost'));
      }
      
      checkLevelUp();
      spawnParticles(e.x, e.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
            
      echoes.splice(j,1);
      echoCountEl.textContent = echoes.length;
    } else {
      // Enemy survived but was still hit - show particles
      spawnParticles(e.x, e.y, 'rgba(255,150,150,0.6)', 5, Math.PI*2, 40);
    }
  }
  
  // Don't remove boomerang bullets on hit
  continue;
  }      
  // Original damage logic for non-boomerang bullets
  const xpMultiplier = 1 + 
  (player.stats.xpBoost.level > 0 ? 0.5 : 0) +                      
  (player.stats.xpBoost.level > 1 ? 0.2 : 0) +                     
  (player.stats.xpBoost.level > 2 ? 0.3 : 0) +
  (player.stats.xpBoost.level > 3 ? 0.2 : 0) +
  (player.stats.xpBoost.level > 4 ? 0.1 : 0);
      
      if (e.takeDamage(b.damage)) {
        if (gameMode !== 'freemode' || player.lives > 0) {
            score += 8;
        }
        echoesKilled++;
        
        let xpAmount = 15;
        let xpMultiplier = 1;
        
        // Level 4: Increase all XP received by 50%
        if (player.stats.xpBoost.level === 4) {
            xpMultiplier = 1.5;
        }
        
        playerXP += xpAmount * xpMultiplier;

        // Level 4: 50% chance for XP orb to spawn when enemy dies
        const xpDropChance = player.stats.xpBoost.level === 4 ? 0.5 : 0;
        
        if (xpDropChance > 0 && Math.random() < xpDropChance) {
            upgrades.push(new Upgrade('xpBoost'));
        }
        
        checkLevelUp();
        spawnParticles(e.x, e.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
        
        if (e instanceof EasyBoss || e instanceof MediumBoss || e instanceof HardBoss || e instanceof FinalBoss || e instanceof MegaCreeperBoss) {
          bossesKilled++;
          
          // Mark boss as killed in schedule
          const bossType = getBossType(e);
          const scheduleIndex = bossSpawnSchedule.findIndex(b => b.type === bossType && !b.killed);
          if (scheduleIndex !== -1) {
            bossSpawnSchedule[scheduleIndex].killed = true;
          }
          
          // Remove from active bosses
          const bossIndex = activeBosses.indexOf(e);
          if (bossIndex !== -1) {
            activeBosses.splice(bossIndex, 1);
            
            // Remove corresponding health bar and adjust offsets
            bossHealthBars.splice(bossIndex, 1);
            
            // Recalculate y offsets for remaining health bars
            bossHealthBars.forEach((bar, index) => {
              bar.yOffset = (index * 30) + 20;
            });
          }
          
          levelUpNotification.style.display = 'block';
          levelUpNotification.querySelector('.level-up-text').textContent = 'Nigaahh!';
          levelUpNotification.querySelector('.level-up-hint').textContent = 'Continue surviving!';
          setTimeout(() => {
            levelUpNotification.style.display = 'none';
          }, 3000);
        }

        function getBossType(boss) {
          if (boss instanceof EasyBoss) return 'easy';
          if (boss instanceof MediumBoss) return 'medium';
          if (boss instanceof HardBoss) return 'hard';
          if (boss instanceof FinalBoss) return 'final';
          if (boss instanceof MegaCreeperBoss) return 'creeper';
          return 'unknown';
        }              
        echoes.splice(j,1);
        echoCountEl.textContent = echoes.length;
      }
      
      // FIXED: For mythical heavy caliber - bullets don't break but mark enemy as hit
      if (b.persistent) {
        b.hitEnemies.push(e);
      } else if (b.powerBullet) {
        b.hitEnemies.push(e);
        if (b.hitEnemies.length >= b.maxHits) {
          bullets.splice(i,1);
          break;
        }
      } else if (!b.boomerang) {
        bullets.splice(i,1);
      }
      break;
    }}}      else if (b.enemy) {

          // ====== MIRROR SHIELD REFLECTION ZONE ======
// In the bullet collision section, modify the reflection logic:
if (reflectiveMirrorActive && player.stats.reflectiveMirror.level > 0) {
  // Check if bullet is within reflection zone AND hasn't been checked yet
  const distanceToPlayer = Math.hypot(b.x - player.x, b.y - player.y);
  
  if (distanceToPlayer < reflectiveMirrorRadius + b.size && !b.mirrorChecked) {
    // Mark this bullet as checked (only check once)
    b.mirrorChecked = true;
    
    // Calculate reflection chance based on level
    const currentChance = reflectiveMirrorChance; // 0.3, 0.5, or 0.6 based on level
    
    // Check if reflection happens (only once!)
    if (Math.random() < currentChance) {
      // Find nearest enemy to target
      let targetEnemy = null;
      let closestDistance = Infinity;
      
      for (const e of echoes) {
        const distance = Math.hypot(b.x - e.x, b.y - e.y);
        if (distance < closestDistance && distance < 600) {
          closestDistance = distance;
          targetEnemy = e;
        }
      }
      
      if (targetEnemy) {
        // Calculate aim towards enemy
        const aimX = targetEnemy.x - b.x;
        const aimY = targetEnemy.y - b.y;
        const distanceToTarget = Math.sqrt(aimX * aimX + aimY * aimY);
        
        if (distanceToTarget > 0) {
          // Convert bullet to player bullet
          b.enemy = false;
          b.color = '#aaffff';
          b.mirrorReflected = true;
          b.dx = aimX / distanceToTarget;
          b.dy = aimY / distanceToTarget;
          
          // Make reflected bullet stronger based on level
          const damageMultiplier = player.stats.reflectiveMirror.level === 3 ? 2 : 
                                  player.stats.reflectiveMirror.level === 2 ? 1.5 : 1;
          b.speed *= 1.8;
          b.damage = damageMultiplier * player.damageMultiplier;
          b.size *= 0.9;
          
          // Piercing effect for reflected bullets (level 3 only)
          if (player.stats.reflectiveMirror.level >= 3) {
            b.piercing = true;
            b.maxPierces = 3;
            b.piercedEnemies = [];
          }
          
          // Visual effects
          spawnParticles(b.x, b.y, 'rgba(170,255,255,0.9)', 25, Math.PI*2, 120);
          
          // Mirror reflection particle burst
          for (let j = 0; j < 12; j++) {
            const angle = (j / 12) * Math.PI * 2;
            particles.push({
              x: b.x,
              y: b.y,
              vx: Math.cos(angle) * 100,
              vy: Math.sin(angle) * 100,
              life: 0.6 + Math.random() * 0.3,
              col: '#aaffff',
              r: 2 + Math.random() * 3
            });
          }
          
          // Screen flash for reflection
          const flash = document.createElement('div');
          flash.style.position = 'fixed';
          flash.style.top = '0';
          flash.style.left = '0';
          flash.style.width = '100%';
          flash.style.height = '100%';
          flash.style.backgroundColor = 'rgba(170,255,255,0.5)';
          flash.style.pointerEvents = 'none';
          flash.style.zIndex = '9998';
          flash.style.transition = 'opacity 0.2s ease-out';
          document.body.appendChild(flash);
          
          setTimeout(() => {
            flash.style.opacity = '0';
            setTimeout(() => {
              if (flash.parentNode) flash.parentNode.removeChild(flash);
            }, 200);
          }, 10);
          
          // Sound effect
          sfx(800, 0.2, 0.03, 'square');
          
          // Skip player damage (bullet was reflected)
          continue;
        }
      }
    }
  }
}

if (b.enemy) {
  const d = Math.hypot(b.x - player.x, b.y - player.y);
  if (d < player.r + b.size && player.invul <= 0 && upgradeInvulTimer <= 0) {

    if (shield > 0 && shieldDamageCooldown <= 0) {
      shield--;
      shieldDamageCooldown = 1.0;
      spawnParticles(player.x, player.y, 'rgba(77,171,247,0.9)', 25, Math.PI*2, 120);
      
      // Shield crack effect
      for (let j = 0; j < 8; j++) {
        const angle = (j / 8) * Math.PI * 2;
        particles.push({
          x: player.x + Math.cos(angle) * (player.r + 8),
          y: player.y + Math.sin(angle) * (player.r + 8),
          vx: Math.cos(angle) * 60,
          vy: Math.sin(angle) * 60,
          life: 0.6,
          col: '#4dabf7',
          r: 3 + Math.random() * 2
        });
      }
      
      // Screen flash effect for shield damage
      createScreenFlash('rgba(77,171,247,0.3)', 0.1);
      
      // Animate shield damage display
      if (typeof animateShieldDamage === 'function') animateShieldDamage();
      
      sfx(600, 0.1, 0.03, 'square');
      bullets.splice(i,1);
      
    } else if (shield <= 0) {
      player.lives--;
      livesEl.textContent = player.lives;
      player.invul = 1.5;
      shake = 10;
      
      // Enhanced damage effect
      spawnParticles(player.x, player.y, 'rgba(255,100,100,0.9)', 30, Math.PI*2, 150);
      
      // Blood splatter effect
      for (let j = 0; j < 15; j++) {
        const angle = Math.random() * Math.PI * 2;
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 80,
          vy: Math.sin(angle) * 80,
          life: 0.8 + Math.random() * 0.4,
          col: '#ff6b6b',
          r: 4 + Math.random() * 3
        });
      }
      
      // Screen flash effect for health damage
      createScreenFlash('rgba(255,100,100,0.4)', 0.15);
      
      // Damage indicator text
      createDamageIndicator(player.x, player.y, '-1');
      
      // Animate health damage display
      if (typeof animateHealthDamage === 'function') animateHealthDamage();
      
      // COOLDOWN REFRESH ability
      if (player.stats.cooldownRefresh.level > 0) {
        emergencyAbilityCooldown = 0;
        abilityCooldown.style.display = 'none';
        emergencyAbilityActive = false;
        
        // Visual effect for cooldown refresh
        spawnParticles(player.x, player.y, 'rgba(0,255,170,0.9)', 20, Math.PI*2, 100);
        sfx(800, 0.2, 0.03, 'sine');
      }

      sfx(200, 0.3, 0.04, 'sawtooth');
      
      shieldTimer = 0;

      // Cooldown Refresh ability (also for enemy collision damage)
      if (player.stats.cooldownRefresh.level > 0) {
        emergencyAbilityCooldown = 0;
        abilityCooldown.style.display = 'none';
        emergencyAbilityActive = false;
        
        // Visual effect for cooldown refresh
        spawnParticles(player.x, player.y, 'rgba(0,255,170,0.9)', 20, Math.PI*2, 100);
        sfx(800, 0.2, 0.03, 'sine');
      }
      
      // ====== CRITICAL FIX: Check if player died ======
      if (player.lives <= 0 && gameMode !== 'freemode') {
        running = false;
        if (score > high){ 
          high = score; 
          localStorage.setItem('echoswap-hi', high); 
          hiEl.textContent = high; 
        }
        
        setTimeout(() => {
          deathScreen.style.display = 'flex';
          finalScore.textContent = score;
          finalTime.textContent = Math.floor(timeAlive) + 's';
          echoesDefeated.textContent = echoesKilled;
          upgradesCollected.textContent = upgradesGathered;
          
          // Show endless mode death message
          if (endlessMode) {
            deathScreen.querySelector('.start-subtitle').textContent = 
              'You survived the endless onslaught! Ready to try again?';
          }
        }, 800);
      }
      // ====== END CRITICAL FIX ======
    }
    
    // Remove the bullet after it hits the player
    bullets.splice(i,1);
  }
      
    // sniper bullets can kill enemies - FIXED
    if (b.sniper) {
      for (let j = echoes.length - 1; j >= 0; j--) {
        const e = echoes[j];
        if (e !== this) {
          const d = Math.hypot(b.x - e.x, b.y - e.y);
          if (d < e.r + b.size) {
            if (e.takeDamage(2)) {
              echoesKilled++;
              echoes.splice(j, 1);
            }
            spawnParticles(e.x, e.y, 'rgba(138,43,226,0.9)', 8, Math.PI*2, 60);
          }
        }
      }
    }
  }
}

    }

    if (bossSpawnEffect) {
      bossSpawnEffect.timer -= dt;
      if (bossSpawnEffect.timer <= 0) {
        bossSpawnEffect = null;
      }
    }

    for (let i = paints.length - 1; i >= 0; i--){
      const p = paints[i];
      p.life -= dt;
      p.r += dt * 6;
      
      // FIXED: Mythical poison area - green area deals damage
      if (player.stats.knockbackBullets.level >= 6) {
        for (const e of echoes) {
          const d = Math.hypot(e.x - p.x, e.y - p.y);
          if (d < p.r + e.r) {
            e.takeDamage(0.1 * dt);
          }
        }
      }
      
      if (p.life <= 0) paints.splice(i,1);
    }

    echoSpawnTimer += dt;
    const spawnInterval = Math.max(0.5, 2.5 - difficulty*0.2) * (endlessMode ? 0.7 : 1);
    if (echoSpawnTimer >= spawnInterval){
      echoSpawnTimer = 0;
      spawnRandomEnemy();
    }

    for (let i = echoes.length - 1; i >= 0; i--){
      const e = echoes[i];
      
      if (e instanceof EasyBoss || e instanceof MediumBoss || e instanceof HardBoss || e instanceof FinalBoss || e instanceof MegaCreeperBoss) {
        if (!e.update(dt)) {
          echoes.splice(i,1);
          bossHealth.style.display = 'none';
        }
        continue;
      }
      
      e.update(dt);
      
      for (const p of paints){
        const d = Math.hypot(e.x - p.x, e.y - p.y);
        if (d < p.r + e.r){
          e.t = Math.max(0, e.t - dt*1.2);
          e.aggro = Math.max(0, e.aggro - dt*0.08);
          if (Math.random() < 0.06) particles.push({x:e.x + (Math.random()-0.5)*10, y:e.y + (Math.random()-0.5)*10, vx:0, vy:0, life:0.6, col:'rgba(120,255,160,0.14)', r: rand(3,8) });
        }
      }
      
      const dx = player.x - e.x, dy = player.y - e.y;
      const d = Math.hypot(dx, dy);
      if (d < player.r + e.r - 3 && player.invul <= 0 && upgradeInvulTimer <= 0) {
        if (shield > 0 && shieldDamageCooldown <= 0) {
          shield--;
          shieldDamageCooldown = 1.0;
          spawnParticles(player.x, player.y, 'rgba(77,171,247,0.9)', 15, Math.PI*2, 80);
          sfx(600, 0.1, 0.03, 'square');
          
          // Damage the enemy back when shield is hit (optional)
          // e.takeDamage(1);
          
        } else if (shield <= 0) {
          player.lives--;
          livesEl.textContent = player.lives;
          player.invul = 1.5;
          shake = 15;
          spawnParticles(player.x, player.y, 'rgba(255,100,100,0.9)', 20, Math.PI*2, 120);
          sfx(200, 0.3, 0.04, 'sawtooth');
          
          shieldTimer = 0;
          
          // ====== COOLDOWN REFRESH - FULL ABILITY RESET ======
          if (player.stats.cooldownRefresh.level > 0) {
            // 1. Reset emergency ability system
            emergencyAbilityCooldown = 0;
            abilityCooldown.style.display = 'none';
            emergencyAbilityActive = false;
            
            // 2. Turn OFF all active ability flags
            minesActive = false;
            lastResortActive = false;
            

            // 4. Reset ALL ability timers to zero
            mineTimer = 0;
            freezeTimer = 0;
            lastResortTimer = 0;
            guardsTimer = 0;
            shockwaveTimer = 0;
            saferSpacesTimer = 0;

            // 5. Hide ability overlays
            freezeOverlay.style.display = 'none';
            
            // 6. Enhanced visual effects
            spawnParticles(player.x, player.y, 'rgba(0,255,170,0.9)', 30, Math.PI*2, 150);
            
            // 7. Screen flash effect (green)
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'rgba(0,255,170,0.075)';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '9998';
            flash.style.transition = 'opacity 0.3s ease-out';
            document.body.appendChild(flash);
            
            setTimeout(() => {
              flash.style.opacity = '0';
              setTimeout(() => {
                if (flash.parentNode) flash.parentNode.removeChild(flash);
              }, 300);
            }, 10);
            
            // 8. Sound effect
            sfx(800, 0.3, 0.04, 'sine');
            
            // 9. On-screen text notification
            const indicator = document.createElement('div');
            indicator.textContent = 'COOLDOWNS REFRESHED!';
            indicator.style.position = 'absolute';
            indicator.style.left = player.x + 'px';
            indicator.style.top = (player.y - 40) + 'px';
            indicator.style.color = '#00ffaa';
            indicator.style.fontSize = '16px';
            indicator.style.fontWeight = 'bold';
            indicator.style.textShadow = '0 0 8px rgba(0,255,170,0.8)';
            indicator.style.pointerEvents = 'none';
            indicator.style.zIndex = '9999';
            indicator.style.transform = 'translate(-50%, -50%)';
            indicator.style.transition = 'all 0.8s ease-out';
            document.body.appendChild(indicator);
            
            setTimeout(() => {
              indicator.style.top = (player.y - 80) + 'px';
              indicator.style.opacity = '0';
              setTimeout(() => {
                if (indicator.parentNode) indicator.parentNode.removeChild(indicator);
              }, 800);
            }, 10);
          }
          // ====== END COOLDOWN REFRESH ======
          
          // Kill the enemy that touched the player
          if (e.takeDamage(999)) { // Deal massive damage to ensure enemy dies
            echoesKilled++;
            if (gameMode !== 'freemode' || player.lives > 0) {
              score += 8;
            }
            
            // XP for killing the enemy
            playerXP += 15;
            checkLevelUp();
            
            // Remove the enemy from the echoes array
            const index = echoes.indexOf(e);
            if (index > -1) {
              echoes.splice(index, 1);
              echoCountEl.textContent = echoes.length;
            }
          }
          
          spawnParticles(e.x, e.y, 'rgba(255,180,120,0.9)', 16, Math.PI*2, 120);
          
          if (player.lives <= 0 && gameMode !== 'freemode') {
            running = false;
            if (score > high){ 
              high = score; 
              localStorage.setItem('echoswap-hi', high); 
              hiEl.textContent = high; 
            }
            
            setTimeout(() => {
              deathScreen.style.display = 'flex';
              finalScore.textContent = score;
              finalTime.textContent = Math.floor(timeAlive) + 's';
              echoesDefeated.textContent = echoesKilled;
              upgradesCollected.textContent = upgradesGathered;
              
              // Show endless mode death message
              if (endlessMode) {
                deathScreen.querySelector('.start-subtitle').textContent = 
                  'You survived the endless onslaught! Ready to try again?';
              }
            }, 800);
          }
        }
      }
    }
    
    if (player.invul > 0) {
      player.invul -= dt;
    }

    // Update post-upgrade invulnerability timer
    if (upgradeInvulTimer > 0) {
        upgradeInvulTimer -= dt;
    }

    for (let i = upgrades.length - 1; i >= 0; i--){
      const u = upgrades[i];

      // XP Boost Level 3 (index 2): Pull XP orbs toward player
      if (u.type === 'xpBoost' && player.stats.xpBoost.level >= 3) {
          const pullRadius = 500; // Increased radius
          const pullSpeed = 300; // Faster pull
          const d = dist({x: u.x, y: u.y}, player);
          
          if (d < pullRadius) {
              const toPlayer = vecTo(u.x, u.y, player.x, player.y);
              u.x += toPlayer.x * pullSpeed * dt;
              u.y += toPlayer.y * pullSpeed * dt;
              
              // Visual trail effect
              if (Math.random() < 0.5) {
                  particles.push({
                      x: u.x,
                      y: u.y,
                      vx: -toPlayer.x * 50,
                      vy: -toPlayer.y * 50,
                      life: 0.4,
                      col: '#FFD700' + 'AA', // Gold color for XP trail
                      r: 2 + Math.random() * 2
                  });
              }
              
              // Connection line to player
              if (Math.random() < 0.1) {
                  particles.push({
                      x: u.x,
                      y: u.y,
                      vx: 0,
                      vy: 0,
                      life: 0.3,
                      col: '#FFD700' + '66',
                      r: 1
                  });
              }
          }
      }
      
      // Existing update logic continues...
      if(!u.update(dt)){
        upgrades.splice(i,1);
        continue;
      }
      
      const d = Math.hypot(player.x - u.x, player.y - u.y);
      if(d < player.r + u.r){
        let baseXP = 30;
        let xpMultiplier = 1;
        
        // XP Boost levels:
        // Level 1 (index 0): Increase base XP to 50
        if (player.stats.xpBoost.level >= 1) {
            baseXP = 50;
        }
        
        // Level 2 (index 1): +50% XP bonus
        if (player.stats.xpBoost.level >= 2) {
            xpMultiplier = 1.5;
        }
        
        // Level 5 (index 4): +50% to all XP received (stacks with level 2)
        if (player.stats.xpBoost.level >= 5) {
            xpMultiplier *= 1.5;
        }
        
        playerXP += baseXP * xpMultiplier;
        upgradesGathered++;
        checkLevelUp();
        upgrades.splice(i,1);
        spawnParticles(u.x, u.y, u.colors[u.type] + 'DD', 20, Math.PI*2, 80);
        sfx(1000, 0.08, 0.025, 'sine');
      }
    }
    
    if (gameStarted && running) {
    const upgradeChance = 0.015 * (1 + (player.stats.xpBoost.level > 0 ? 0.5 : 0));
    if(upgrades.length < 2 && Math.random() < upgradeChance){
      const availableTypes = [];
      for (const stat in player.stats) {
        if (stat === 'shieldRegen' && player.stats.shield.level === 0) {
          continue;
        }
        
        // In hardcore mode, skip extra life and shield upgrades
        if (gameMode === 'hardcore' && 
            (stat === 'extraLife' || stat === 'shield' || stat === 'health' || stat === 'holyLife')) {
          continue;
        }
        
        if (player.stats[stat].level < player.stats[stat].max) {
          availableTypes.push(stat);
        }
      }
      
      if (availableTypes.length > 0) {
        const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        upgrades.push(new Upgrade(type));
      }
    }
  }
    
    checkBossSpawn(dt);

    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      p.life -= dt;
      p.x += (p.vx||0) * dt;
      p.y += (p.vy||0) * dt;
      if (p.life <= 0) particles.splice(i,1);
    }

    shake = Math.max(0, shake - dt*18);
  }

  // rendering
  function render(){
    const sx = (Math.random()-0.5)*shake, sy = (Math.random()-0.5)*shake;
    ctx.save(); ctx.translate(sx, sy);

    if (bossSpawnEffect) {
      const progress = 1 - (bossSpawnEffect.timer / bossSpawnEffect.maxTimer);
      const size = 200 + progress * 200;
      const alpha = 0.8 * (1 - progress);
      
      ctx.fillStyle = `rgba(255,0,0,${alpha})`;
      ctx.beginPath();
      ctx.arc(bossSpawnEffect.x, bossSpawnEffect.y, size, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.clearRect(0,0,W,H);
    
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    const gridSize = 50;
    for (let x = 0; x < W; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    for (let y = 0; y < H; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }

    // Draw lightning strikes
    for (const lightning of lightningStrikes) {
      lightning.draw(ctx);
    }
    
    for (let i=0;i<80;i++){
      const sx = (i*137.5 + timeAlive*14) % W;
      const sy = (i*97.3 + timeAlive*7) % H;
      const size = 1 + Math.sin(i + timeAlive) * 0.5;
      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.fillRect(sx, sy, size, size);
    }

        // Draw golden glow during Last Resort
    if (lastResortActive) {
        const pulse = 0.7 + Math.sin(lastResortEffectTimer * 10) * 0.3;
        
        // Outer glow
        const outerGlow = ctx.createRadialGradient(
            player.x, player.y, player.r,
            player.x, player.y, player.r * 4
        );
        outerGlow.addColorStop(0, `rgba(255, 255, 100, ${0.3 * pulse})`);
        outerGlow.addColorStop(1, `rgba(255, 200, 0, 0)`);
        
        ctx.fillStyle = outerGlow;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.r * 4, 0, Math.PI*2);
        ctx.fill();
        
        // Inner glow
        const innerGlow = ctx.createRadialGradient(
            player.x, player.y, 0,
            player.x, player.y, player.r * 2
        );
        innerGlow.addColorStop(0, `rgba(255, 255, 200, ${0.5 * pulse})`);
        innerGlow.addColorStop(1, `rgba(255, 255, 100, 0)`);
        
        ctx.fillStyle = innerGlow;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.r * 2, 0, Math.PI*2);
        ctx.fill();
        
        // Draw golden trail
        for (let i = 0; i < player.trail.length; i++) {
            const point = player.trail[i];
            const alpha = (i / player.trail.length) * 0.6;
            
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.fillStyle = `rgba(255, 255, 100, ${alpha})`;
            ctx.arc(point.x, point.y, player.r * (i / player.trail.length), 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    for (const p of paints){
      ctx.beginPath();
      const g = ctx.createRadialGradient(p.x, p.y, 1, p.x, p.y, p.r*1.6);
      g.addColorStop(0, 'rgba(160,255,180,0.18)');
      g.addColorStop(1, 'rgba(80,200,120,0.02)');
      ctx.fillStyle = g; ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.fillStyle = 'rgba(140,255,170,0.28)'; ctx.arc(p.x,p.y,p.r*0.46,0,Math.PI*2); ctx.fill();
    }

    for (const indicator of spawnIndicators) {
      indicator.draw(ctx);
    }

    for (const shockwave of shockwaves) {
      shockwave.draw(ctx);
    }

    for (const guard of guards) {
      guard.draw(ctx);
    }

    // Draw safer spaces wall
    if (saferSpacesActive && saferSpacesWall && saferSpacesTimer > 0) {
      const alpha = saferSpacesTimer / 10;
      ctx.strokeStyle = `rgba(0,255,255,${alpha * 0.8})`;
      ctx.lineWidth = 4;
      ctx.strokeRect(
        saferSpacesWall.x - saferSpacesWall.width/2,
        saferSpacesWall.y - saferSpacesWall.height/2,
        saferSpacesWall.width,
        saferSpacesWall.height
      );
      
      ctx.fillStyle = `rgba(0,255,255,${alpha * 0.2})`;
      ctx.fillRect(
        saferSpacesWall.x - saferSpacesWall.width/2,
        saferSpacesWall.y - saferSpacesWall.height/2,
        saferSpacesWall.width,
        saferSpacesWall.height
      );
      
      // Draw health indicator
      const healthPercent = saferSpacesHealth / 5;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(saferSpacesWall.x - 40, saferSpacesWall.y - saferSpacesWall.height/2 - 10, 80, 6);
      
      ctx.fillStyle = healthPercent > 0.5 ? '#00ffff' : '#ff6b6b';
      ctx.fillRect(saferSpacesWall.x - 40, saferSpacesWall.y - saferSpacesWall.height/2 - 10, 80 * healthPercent, 6);
    }

    // Draw damage zone (passive) - ENHANCED VERSION
    if (damageZoneActive && player.stats.damageZone.level > 0) {
      damageZonePulse += 0.08;
      damageZoneInnerPulse += 0.15;
      damageZoneRotation += 0.03;
      
      const swordCount = player.stats.damageZone.level === 1 ? 1 : 2;
      const damageMultiplier = player.stats.damageZone.level === 2 ? 2 : 1.5;
      const areaMultiplier = player.stats.damageZone.level === 2 ? 1.5 : 1.0;
      const zoneRadius = player.r * 6 * areaMultiplier;
      
      // Pulsing outer aura effect
      const outerPulse = 0.7 + Math.sin(damageZonePulse) * 0.3;
      const innerPulse = 0.5 + Math.sin(damageZoneInnerPulse) * 0.5;
      
      // Outer glow with pulsing effect
      const outerGlow = ctx.createRadialGradient(
        player.x, player.y, player.r * 2,
        player.x, player.y, zoneRadius * 1.2
      );
      outerGlow.addColorStop(0, `rgba(255, 50, 50, ${0.15 * outerPulse})`);
      outerGlow.addColorStop(0.5, `rgba(255, 107, 107, ${0.08 * outerPulse})`);
      outerGlow.addColorStop(1, `rgba(255, 150, 150, ${0.02 * outerPulse})`);
      
      ctx.beginPath();
      ctx.fillStyle = outerGlow;
      ctx.arc(player.x, player.y, zoneRadius * 1.2, 0, Math.PI * 2);
      ctx.fill();
      
      // Main damage zone ring with pulsing effect
      const ringGradient = ctx.createRadialGradient(
        player.x, player.y, zoneRadius * 0.3,
        player.x, player.y, zoneRadius
      );
      ringGradient.addColorStop(0, `rgba(255, 107, 107, ${0.3 * innerPulse})`);
      ringGradient.addColorStop(0.7, `rgba(255, 50, 50, ${0.15 * innerPulse})`);
      ringGradient.addColorStop(1, `rgba(255, 0, 0, ${0.05 * innerPulse})`);
      
      ctx.beginPath();
      ctx.fillStyle = ringGradient;
      ctx.arc(player.x, player.y, zoneRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Pulsing border
      ctx.beginPath();
      ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 * innerPulse})`;
      ctx.lineWidth = 2;
      ctx.arc(player.x, player.y, zoneRadius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner danger ring
      ctx.beginPath();
      ctx.strokeStyle = `rgba(255, 100, 100, ${0.5 * outerPulse})`;
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]);
      ctx.arc(player.x, player.y, zoneRadius * 0.5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Rotating energy blades/swords
      for (let i = 0; i < swordCount; i++) {
        const angle = damageZoneRotation + (i * Math.PI);
        const swordX = player.x + Math.cos(angle) * zoneRadius * 0.7;
        const swordY = player.y + Math.sin(angle) * zoneRadius * 0.7;
        
        // Sword energy trail
        for (let j = 0; j < 3; j++) {
          const trailAngle = angle - 0.1 * j;
          const trailX = player.x + Math.cos(trailAngle) * zoneRadius * (0.7 - j * 0.1);
          const trailY = player.y + Math.sin(trailAngle) * zoneRadius * (0.7 - j * 0.1);
          
          ctx.beginPath();
          ctx.fillStyle = `rgba(255, 200, 100, ${0.3 - j * 0.1})`;
          ctx.arc(trailX, trailY, player.r * 0.3, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw enhanced rotating swords
        ctx.save();
        ctx.translate(swordX, swordY);
        ctx.rotate(angle);
        
        // Sword glow effect
        const swordGlow = ctx.createRadialGradient(0, 0, 1, 0, 0, player.r);
        swordGlow.addColorStop(0, `rgba(255, 255, 200, ${0.8 * outerPulse})`);
        swordGlow.addColorStop(1, `rgba(255, 100, 50, ${0.3 * outerPulse})`);
        
        ctx.beginPath();
        ctx.fillStyle = swordGlow;
        ctx.arc(0, 0, player.r, 0, Math.PI * 2);
        ctx.fill();
        
        // Sword blade with glowing effect
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * innerPulse})`;
        ctx.moveTo(0, -player.r * 0.8);
        ctx.lineTo(player.r * 0.4, player.r * 0.6);
        ctx.lineTo(0, player.r * 0.4);
        ctx.lineTo(-player.r * 0.4, player.r * 0.6);
        ctx.closePath();
        ctx.fill();
        
        // Sword edge highlight
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 255, 100, ${0.8 * outerPulse})`;
        ctx.lineWidth = 1;
        ctx.moveTo(0, -player.r * 0.7);
        ctx.lineTo(0, player.r * 0.3);
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Rotating energy particles around the zone
      const particleCount = 12;
      for (let i = 0; i < particleCount; i++) {
        const particleAngle = damageZoneRotation * 2 + (i / particleCount) * Math.PI * 2;
        const particleDistance = zoneRadius * (0.8 + Math.sin(damageZonePulse + i) * 0.2);
        const particleX = player.x + Math.cos(particleAngle) * particleDistance;
        const particleY = player.y + Math.sin(particleAngle) * particleDistance;
        
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, ${150 + Math.sin(damageZonePulse + i) * 100}, 50, 0.6)`;
        ctx.arc(particleX, particleY, 2 + Math.sin(damageZonePulse + i * 0.5), 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Connection lines between swords and center
      if (swordCount > 1) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255, 100, 100, ${0.3 * innerPulse})`;
        ctx.lineWidth = 1;
        ctx.moveTo(
          player.x + Math.cos(damageZoneRotation) * zoneRadius * 0.7,
          player.y + Math.sin(damageZoneRotation) * zoneRadius * 0.7
        );
        ctx.lineTo(
          player.x + Math.cos(damageZoneRotation + Math.PI) * zoneRadius * 0.7,
          player.y + Math.sin(damageZoneRotation + Math.PI) * zoneRadius * 0.7
        );
        ctx.stroke();
      }
      
      // Damage effect particles on enemies
      for (const e of echoes) {
        const d = dist({x: player.x, y: player.y}, e);
        if (d < zoneRadius + e.r) {
          // Visual feedback for enemies being damaged
          if (Math.random() < 0.1) {
            const angle = Math.atan2(e.y - player.y, e.x - player.x);
            damageZoneDamageParticles.push({
              x: e.x,
              y: e.y,
              vx: Math.cos(angle + Math.PI) * 50,
              vy: Math.sin(angle + Math.PI) * 50,
              life: 0.5,
              color: `rgba(255, ${100 + Math.random() * 100}, 50, 0.8)`,
              size: 3 + Math.random() * 3
            });
          }
        }
      }
      
      // Update and draw damage particles
      for (let i = damageZoneDamageParticles.length - 1; i >= 0; i--) {
        const p = damageZoneDamageParticles[i];
        p.life -= 0.016;
        p.x += p.vx * 0.016;
        p.y += p.vy * 0.016;
        
        if (p.life > 0) {
          ctx.beginPath();
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life;
          ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        } else {
          damageZoneDamageParticles.splice(i, 1);
        }
      }
    }
    // Draw minigun bullets
    for (const b of minigunBullets) {
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,200,100,0.95)';
      ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
      ctx.fill();
    }

    for(let i = 0; i < player.trail.length; i++){
      const point = player.trail[i];
      const alpha = i / player.trail.length * 0.4;
      ctx.beginPath();
      ctx.fillStyle = `rgba(126,231,135,${alpha})`;
      ctx.arc(point.x, point.y, player.r * (i / player.trail.length), 0, Math.PI*2);
      ctx.fill();
    }

    for (const ghost of ghosts) {
      ghost.draw(ctx);
    }

    for (const rocket of rockets) {
      rocket.draw(ctx);
    }

    for (const fire of fires) {
      fire.draw(ctx);
    }

    for (const e of echoes) e.draw(ctx);

    for (const u of upgrades) u.draw(ctx);

    for (const w of player.workers) w.draw(ctx);

    // Draw mines
    for (const mine of mines) {
      const pulseSize = 1 + Math.sin(mine.pulse) * 0.2;
      
      // Outer glow
      const g = ctx.createRadialGradient(mine.x, mine.y, 1, mine.x, mine.y, mine.r * 3);
      g.addColorStop(0, mine.color + 'DD');
      g.addColorStop(1, mine.color + '11');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(mine.x, mine.y, mine.r * 3, 0, Math.PI*2);
      ctx.fill();
      
      // Mine body
      ctx.beginPath();
      ctx.fillStyle = mine.color;
      ctx.arc(mine.x, mine.y, mine.r * pulseSize, 0, Math.PI*2);
      ctx.fill();
      
      // Warning blink when about to expire
      if (mine.life < 2) {
        const blink = Math.sin(mine.life * 10) > 0 ? 1 : 0;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,50,50,${blink * 0.7})`;
        ctx.arc(mine.x, mine.y, mine.r * 1.5, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Danger symbol
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('!', mine.x, mine.y);
    }

    for (const b of bullets){
      ctx.beginPath();
      ctx.fillStyle = b.color || (b.boomerang ? 'rgba(255,100,255,0.95)' : 
                                b.shotgun ? 'rgba(255,200,100,0.95)' : 
                                b.powerBullet ? 'rgba(255,100,100,0.95)' : 'rgba(255,255,255,0.95)');
      ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fill();
      
      ctx.beginPath();
      const gg = ctx.createRadialGradient(b.x,b.y,1,b.x,b.y,20);
      
      if (b.enemy) {
        const pulse = 0.7 + Math.sin(timeAlive * 10) * 0.3;
        gg.addColorStop(0, `rgba(255, ${70 * pulse}, ${70 * pulse}, 0.9)`);
        gg.addColorStop(1, `rgba(255, ${40 * pulse}, ${40 * pulse}, 0.02)`);
      } else {
        const color = b.boomerang ? 'rgba(255,100,255,0.9)' : 
             b.shotgun ? 'rgba(255,200,100,0.9)' :
             b.powerBullet ? 'rgba(255,100,100,0.9)' :
             b.worker ? 'rgba(77,171,247,0.9)' :
             b.flanker ? 'rgba(116,192,252,0.9)' : // Blue color for flanker bullets
             'rgba(255,255,255,0.9)';
            const endColor = b.boomerang ? 'rgba(255,100,255,0.02)' : 
                b.shotgun ? 'rgba(255,200,100,0.02)' :
                b.flanker ? 'rgba(116,192,252,0.02)' : // Blue trail for flanker bullets
                b.powerBullet ? 'rgba(255,100,100,0.02)' :
                b.worker ? 'rgba(77,171,247,0.02)' : 'rgba(255,255,255,0.02)';
        gg.addColorStop(0, color);
        gg.addColorStop(1, endColor);
      }
      
      ctx.fillStyle = gg; 
      ctx.arc(b.x,b.y,18,0,Math.PI*2); 
      ctx.fill();
      
    if (b.powerBullet) {
      ctx.strokeStyle = 'rgba(255,100,100,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size * 1.2, 0, Math.PI*2);
      ctx.stroke();
    }
    
    // === FLANKER VISUAL EFFECT ===
    if (b.flanker) {
      // Add a pulsing glow effect
      const pulse = 0.7 + Math.sin(timeAlive * 10) * 0.3;
      ctx.beginPath();
      ctx.strokeStyle = `rgba(116,192,252,${pulse * 0.5})`;
      ctx.lineWidth = 2;
      ctx.arc(b.x, b.y, b.size * 1.5, 0, Math.PI*2);
      ctx.stroke();
      
      // Add wing-like effect for flanker bullets (pointing backwards)
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(Math.atan2(b.dy, b.dx));
      
      ctx.beginPath();
      ctx.fillStyle = `rgba(116,192,252,${pulse * 0.3})`;
      ctx.moveTo(0, -b.size * 1.5);
      ctx.lineTo(-b.size * 2, -b.size * 0.5);
      ctx.lineTo(-b.size * 2, b.size * 0.5);
      ctx.lineTo(0, b.size * 1.5);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    }
    // === END FLANKER VISUAL EFFECT ===
    
  } // End of for (const b of bullets) loop

    // Combine regular invul, and upgrade invul
    const hasInvul = player.invul > 0 || upgradeInvulTimer > 0;
    const invulTimer = player.invul > 0 ? player.invul : (upgradeInvulTimer);
    const invulEffect = hasInvul ? Math.sin(invulTimer * 10) * 0.5 + 0.5 : 1;
    const playerAlpha = hasInvul ? 0.5 + invulEffect * 0.5 : 1;
    
    ctx.globalAlpha = playerAlpha;
    ctx.beginPath();
    const pg = ctx.createRadialGradient(player.x, player.y, player.r*0.2, player.x, player.y, player.r*4);
    pg.addColorStop(0, 'rgba(126,231,135,0.95)'); pg.addColorStop(1, 'rgba(126,231,135,0.02)');
    ctx.fillStyle = pg; ctx.arc(player.x, player.y, player.r*3.6, 0, Math.PI*2); ctx.fill();
    
    ctx.beginPath(); 
    ctx.fillStyle = '#7ee787'; 
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); 
    ctx.fill();
    
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 2;
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.arc(player.x, player.y, player.r*0.5, 0, Math.PI*2);
    ctx.fill();
    
    if (!player.autoAim) {
      const aim = vecTo(player.x, player.y, input.mx, input.my);
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 2;
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(player.x + aim.x * player.r*1.2, player.y + aim.y * player.r*1.2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Draw upgrade invulnerability effect (blue tint)
    if (upgradeInvulTimer > 0) {
        const pulse = Math.sin(upgradeInvulTimer * 10) * 0.3 + 0.7;
        ctx.beginPath();
        ctx.strokeStyle = `rgba(100, 200, 255, ${pulse * 0.6})`;
        ctx.lineWidth = 4;
        ctx.arc(player.x, player.y, player.r + 8, 0, Math.PI * 2);
        ctx.stroke();
    }

    if (shield > 0) {
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(77,171,247,0.8)';
      ctx.lineWidth = 3;
      ctx.arc(player.x, player.y, player.r + 5, 0, Math.PI*2);
      ctx.stroke();
      
      const maxShield = player.stats.shield.level === 1 ? 3 : 
                       player.stats.shield.level === 2 ? 5 : 6;
      const segmentAngle = (Math.PI * 2) / maxShield;
      for (let i = 0; i < shield; i++) {
        const startAngle = i * segmentAngle;
        const endAngle = (i + 1) * segmentAngle;
        
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(77,171,247,0.9)';
        ctx.lineWidth = 4;
        ctx.arc(player.x, player.y, player.r + 5, startAngle, endAngle);
        ctx.stroke();
      }
    }

          // Draw Mirror Shield reflection zone
      if (reflectiveMirrorActive && player.stats.reflectiveMirror.level > 0) {
        reflectiveMirrorPulse += 0.05;
        const pulseEffect = 0.7 + Math.sin(reflectiveMirrorPulse) * 0.3;
        
        // Outer transparent zone
        const zoneGradient = ctx.createRadialGradient(
          player.x, player.y, player.r + 10,
          player.x, player.y, reflectiveMirrorRadius
        );
        zoneGradient.addColorStop(0, `rgba(170,255,255,${0.15 * pulseEffect})`);
        zoneGradient.addColorStop(1, `rgba(170,255,255,${0.03 * pulseEffect})`);
        
        ctx.beginPath();
        ctx.fillStyle = zoneGradient;
        ctx.arc(player.x, player.y, reflectiveMirrorRadius, 0, Math.PI*2);
        ctx.fill();
        
        // Pulsing border
        ctx.beginPath();
        ctx.strokeStyle = `rgba(170,255,255,${0.3 * pulseEffect})`;
        ctx.lineWidth = 2;
        ctx.arc(player.x, player.y, reflectiveMirrorRadius, 0, Math.PI*2);
        ctx.stroke();
        
        // Rotating mirror fragments
        const fragmentCount = player.stats.reflectiveMirror.level * 3; // 3, 6, or 9 fragments
        for (let i = 0; i < fragmentCount; i++) {
          const angle = reflectiveMirrorPulse * 1 + (i * Math.PI * 2 / fragmentCount);
          const fragmentX = player.x + Math.cos(angle) * (reflectiveMirrorRadius * 0.7);
          const fragmentY = player.y + Math.sin(angle) * (reflectiveMirrorRadius * 0.7);
          
          ctx.save();
          ctx.translate(fragmentX, fragmentY);
          ctx.rotate(angle);
          
          // Draw diamond-shaped mirror fragment
          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${0.2 * pulseEffect})`;
          ctx.moveTo(0, -4);
          ctx.lineTo(3, 0);
          ctx.lineTo(0, 4);
          ctx.lineTo(-3, 0);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }
        
        // Chance indicator text
        if (player.invul <= 0 && shieldDamageCooldown <= 0) {
          ctx.fillStyle = `rgba(170,255,255,${0.2 * pulseEffect})`;
          ctx.font = '8px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`${Math.round(reflectiveMirrorChance * 100)}%`, player.x, player.y + reflectiveMirrorRadius + 15);
          ctx.textAlign = 'left';
        }
      }


    if (player.autoAim) {
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.font = '12px sans-serif';
      ctx.fillText('AUTO-AIM ACTIVE', 10, H - 20);
    }

    if (player.autoFireToggle) {
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.font = '12px sans-serif';
      ctx.fillText('AUTO-FIRE ACTIVE', 10, H - 40);
    }

    if (killBoostTimer > 0) {
      const boostDuration = player.stats.killBoost.level === 1 ? 3 : 
                           player.stats.killBoost.level === 2 ? 4 : 
                           player.stats.killBoost.level === 4 ? 1 : 5;
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(10, H - 80, 100, 8);
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(10, H - 80, 100 * (killBoostTimer / boostDuration), 8);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.font = '10px sans-serif';
      ctx.fillText('BOOST', 12, H - 72);
    }

    if (player.stats.shield.level > 0) {
      const maxShield = player.stats.shield.level === 1 ? 3 : 
                       player.stats.shield.level === 2 ? 5 : 6;
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(10, H - 100, 100, 8);
      ctx.fillStyle = '#4dabf7';
      ctx.fillRect(10, H - 100, 100 * (shield / maxShield), 8);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.font = '10px sans-serif';
      ctx.fillText('SHIELD', 12, H - 92);
    }



    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.font = '12px sans-serif';
    const abilityNames = {
      tripleShot: 'TRIPLE SHOT',
      shockwave: 'SHOCKWAVE',
      guards: 'GUARDS',
      freeze: 'FREEZE',
      lastResort: 'LAST RESORT',
      damageZone: 'DAMAGE ZONE',
      saferSpaces: 'SAFER SPACES'
    };
    ctx.fillText(`ABILITY: ${abilityNames[emergencyAbility]}`, 10, H - 140);



    // Render multiple boss health bars
    for (let i = 0; i < bossHealthBars.length; i++) {
      const bar = bossHealthBars[i];
      if (!bar.boss || bar.boss.health <= 0) continue;
      
      const yPos = bar.yOffset;
      const healthPercent = bar.boss.health / bar.boss.maxHealth;
      
      // Health bar background
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(W/2 - 150, yPos, 300, 20);
      
      // Health bar fill
      ctx.fillStyle = 'rgba(255,107,107,0.9)';
      ctx.fillRect(W/2 - 150, yPos, 300 * healthPercent, 20);
      
      // Border
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 2;
      ctx.strokeRect(W/2 - 150, yPos, 300, 20);
      
      // Boss name and health text
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      
      let bossName = '';
      if (bar.boss instanceof EasyBoss) bossName = 'EASY BOSS';
      else if (bar.boss instanceof MediumBoss) bossName = 'MEDIUM BOSS';
      else if (bar.boss instanceof HardBoss) bossName = 'HARD BOSS';
      else if (bar.boss instanceof FinalBoss) bossName = 'FINAL BOSS';
      else if (bar.boss instanceof MegaCreeperBoss) bossName = 'CREEPER BOSS';
      
      ctx.fillText(`${bossName}: ${Math.ceil(bar.boss.health)}/${bar.boss.maxHealth}`, W/2, yPos + 14);
      ctx.textAlign = 'left';
    }

    for (const p of particles){
      ctx.beginPath();
      ctx.fillStyle = p.col || 'rgba(255,255,255,0.9)';
      ctx.globalAlpha = Math.max(0, p.life / 1.2);
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.fillStyle = 'rgba(0,0,0,0.5)'; 
    ctx.fillRect(10,10,280,86);
    ctx.fillStyle = '#fff'; 
    ctx.font = '14px sans-serif'; 
    ctx.fillText('Score: ' + score, 22, 30);
    ctx.fillText('Echoes: ' + echoes.length, 22, 50);
    ctx.fillText('Level: ' + playerLevel, 22, 70);
    ctx.fillText('Lives: ' + player.lives, 22, 90);
    
    if (!maxLevelReached) {
      const xpPercent = playerXP / xpToNextLevel;
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(W - 210, 20, 200, 12);
      ctx.fillStyle = '#7ee787';
      ctx.fillRect(W - 210, 20, 200 * xpPercent, 12);
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 1;
      ctx.strokeRect(W - 210, 20, 200, 12);
      ctx.fillStyle = '#fff';
      ctx.font = '10px sans-serif';
      ctx.fillText('XP: ' + playerXP + '/' + xpToNextLevel, W - 205, 30);
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(W - 210, 20, 200, 12);
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(W - 210, 20, 200, 12);
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 1;
      ctx.strokeRect(W - 210, 20, 200, 12);
      ctx.fillStyle = '#fff';
      ctx.font = '10px sans-serif';
      ctx.fillText('MAX LEVEL REACHED', W - 205, 30);
    }
    
    if (player.autoFireToggle) {
      const autoFirePercent = autoFireTimer / player.fireRate;
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(W - 210, 40, 200, 8);
      ctx.fillStyle = '#74c0fc';
      ctx.fillRect(W - 210, 40, 200 * autoFirePercent, 8);
    }
    
    if (player.maxWorkers > 0) {
        ctx.fillStyle = '#63e6be';
        ctx.font = '12px sans-serif';
        ctx.fillText('Bots: ' + player.workers.length, W - 210, 65);
    }
    
    if (pendingUpgrades > 0 && !maxLevelReached) {
      ctx.fillStyle = 'rgba(126,231,135,0.8)';
      ctx.font = '12px sans-serif';
      ctx.fillText('Upgrades: ' + pendingUpgrades, W - 210, 85);
    }
    
    if (endlessMode) {
      ctx.fillStyle = 'rgba(255,100,100,0.8)';
      ctx.font = '12px sans-serif';
      ctx.fillText('ENDLESS MODE', W/2 - 50, 30);
    }
    
    if (gameMode === 'hardcore') {
      ctx.fillStyle = 'rgba(255,100,100,0.8)';
      ctx.font = '12px sans-serif';
      ctx.fillText('HARDCORE', W/2 - 40, 50);
    }
    
    if (gameMode === 'freemode') {
      ctx.fillStyle = 'rgba(100,100,255,0.8)';
      ctx.font = '12px sans-serif';
      ctx.fillText('FREEMODE', W/2 - 40, 50);
    }

    ctx.restore();
  }

  function updateUI(){ 
    scoreEl.textContent = score; 
    timeEl.textContent = Math.floor(timeAlive) + 's'; 
    echoCountEl.textContent = echoes.length; 
    hiEl.textContent = high; 
    levelEl.textContent = playerLevel;
    livesEl.textContent = player.lives;
    
    // Update health display
    if (typeof updateHealthDisplay === 'function') {
      updateHealthDisplay();
    }
  }

  function loop(now){
    const dt = Math.min(0.05, (now - lastTime)/1000);
    lastTime = now;
    if(running && gameStarted && !gamePaused) step(dt);
    render();
    requestAnimationFrame(loop);
  }

  // Initialize the game
  initAudio();
  requestAnimationFrame(loop);

  window.es = { bullets, echoes, paints, particles, player };
})();
</script>
</body>
</html>
